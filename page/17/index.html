<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="计算机 比特币 互联网金融 IFWallet" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="区块链爱好者，互联网从业者">
<meta name="keywords" content="bibodeng, blockchain, bitcoin, bitcoin cash, life, programmer">
<meta property="og:type" content="website">
<meta property="og:title" content="bibodeng">
<meta property="og:url" content="https://bibodeng.github.io/page/17/index.html">
<meta property="og:site_name" content="bibodeng">
<meta property="og:description" content="区块链爱好者，互联网从业者">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="bibodeng">
<meta name="twitter:description" content="区块链爱好者，互联网从业者">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> bibodeng </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">bibodeng</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Think By My Mind</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2012/04/27/读人月神话/" itemprop="url">
                  读人月神话
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2012-04-27T18:23:02+08:00" content="2012-04-27">
              2012-04-27
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2012/04/27/读人月神话/" class="leancloud_visitors" data-flag-title="读人月神话">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
<p><span style="font-family:'Microsoft YaHei';font-size:14px;">【误打误撞】</span></p>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><p><span style="font-family:'Microsoft YaHei';font-size:14px;">都不知道怎么碰到这本书，大一就在图书馆瞄过，后来很多书都提到这本神秘的著作。在kindle上读这本书，算得上是茶余饭后的消遣之物。如果说这时软件工程的一本经典之作，那么它还是适合那些产品经理以及项目负责人，当然对于一般的想要自己开发项目的同学也可以看看，算是了解一些基本的软件工程概念。</span></p>
<p><span style="font-family:'Microsoft YaHei';font-size:14px;"><a target="_blank" href="/content/plugins/kl_album/upload/201204/026e32db9e376104982c3500c6a977a42012042712475220404.jpg"><img src="/content/plugins/kl_album/upload/201204/026e32db9e376104982c3500c6a977a42012042712475220404.jpg" width="254" height="360" alt="点击查看原图" border="0"></a><br>
</span></p>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><p><span style="font-family:'Microsoft YaHei';font-size:14px;">【人月神话】</span></p>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><p><span style="font-family:'Microsoft YaHei';font-size:14px;">本书的译名容易让人浮想连篇到奇幻小说，其实这里的“人月”是指软件开发中人力与时间的关系，他们并不是简单的对等的，而是一个更加复杂的函数。当项目进行到时间不够的时候，简单的加派人手只会让情况更糟糕，因为项目在于沟通，在于构建整体的系统。</span></p>
<p><span style="font-family:''Microsoft YaHei'';"><span style="font-size:14px;line-height:21px;">而本书，不仅仅是人月之间的关系，而且有一般软件工程应该注意的问题，比如团队组织，空间、银弹——开发技术，时间日程表等等。而且时代是一直在进步的，技术和概念上的更新需要付出更多的努力追赶前进方向。往往所做的第一个原型，是要被丢弃的，因为它太难用或者性能很低下，而设计又要随着时间而改变，故而一个真正的软件其工程量远远超乎我们想象的若干人年，它的任务会一直延续到它完成所有的使命，直到有新的软件新的设计去替代它。</span></span></p>
<p><span style="font-family:''Microsoft YaHei'';"><span style="font-size:14px;line-height:21px;"><br>
</span></span></p>
<p><span style="font-family:''Microsoft YaHei'';"><span style="font-size:14px;line-height:21px;">【我关心的东西】</span></span></p>
<p></p>
<ul><li><span style="font-family:'Microsoft YaHei';font-size:14px;line-height:21px;color:#009900;">数据的表现形式是编程的根本</span></li>
</ul>
<p></p>
<p><span style="font-family:''Microsoft YaHei'';"><span style="font-size:14px;line-height:21px;">记得pascal之父Niklaus wirth说过 "程序 = 算法 + 数据结构"，这是有道理的，我们编程就是为了将数据表现成我们想要的形式，而最终的形式是和数据结构有关系的，而这个表现结果就是算法的最终产物。《编程珠玑》里有单独一章介绍数据的表示，就是简简单单的数组都非常有用——高效地解决了很多冗余或者适合线性迭代的问题。而编程高手们一直告诫我们编程之间先多思考，多思考，多想想采用怎样的数据结构来表现数据会比较适合后面的处理以及结果的表示。编程之前多花点时间去做抽象、归纳、发散会减少编写代码的时间。稍后我们也会讲到布鲁克斯书中经典的项目时间安排（编码只占很小一部分）。</span></span></p>
<p><span style="font-family:''Microsoft YaHei'';"><span style="font-size:14px;line-height:21px;">让我们来举几个例子，排序是程序员的看家本领，而编程是为了让数据最后以有序的方法表现出来，故而怎样表现就是<a href="/?post=33">排序的核心所在，于是有非常多的算法用不同的思想：归并，堆（这个更加符合 niklaus的等式），插入，基数等等</a>。 再如，我们编写一个从数据库查询信息然后生成报表，最后的报表就是数据的表现形式。编程，是将机器里面的数据表达成我们人类容易理解的形式；程序员也就是翻译人员。</span></span></p>
<p><span style="font-family:''Microsoft YaHei'';"><span style="font-size:14px;line-height:21px;">虽然这句话有一定的道理，但是貌似有点忽略了算法的重要性，表现形式虽然是根本，但是其中隐藏的实现和实现过程也是不容忽视的。</span></span></p>
<p></p>
<ul><li><span style="font-family:''Microsoft YaHei'';"><span style="font-size:14px;line-height:21px;color:#009900;">时间的重要性</span></span></li>
</ul>
<p><span style="font-family:''Microsoft YaHei'';"><span style="font-size:14px;line-height:21px;">时间是工程中相当重要的因素，一个大型的软件要能在它规定的时间范围内开发出来，这样才能发挥作用，要不然到时候发现不适合了，太陈旧了，不能用了。故而开发之前就要有很好的时间日程表，按照日程表达到相应的里程碑。各种各样的原因会造成项目的拖延，虽然每次只拖延一天，但是久而久之就可能把项目拖黄。我们应该有足够的远见预料到麻烦所在，以及分配时间去解决那些关键路径上的问题。</span></span></p>
<p><span style="font-family:''Microsoft YaHei'';"><span style="font-size:14px;line-height:21px;">时间的分配也十分有趣，三分之一用于设计，六分之一用于编码，四分之一用于模块测试，四分之一用于系统测试。</span></span></p>
<p><span style="font-family:''Microsoft YaHei'';"><span style="font-size:14px;line-height:21px;"><br>
</span></span></p>
<p></p>
<ul><li><span style="font-family:''Microsoft YaHei'';"><span style="font-size:14px;line-height:21px;color:#009900;">文档的力量</span></span></li>
</ul>
<p><span style="font-family:''Microsoft YaHei'';"><span style="font-size:14px;line-height:21px;">遇到问题记下来，有记录，分歧才会明朗，矛盾才会突出。</span></span></p>
<p><span style="font-family:''Microsoft YaHei'';"><span style="font-size:14px;line-height:21px;">的的确确是这样的，<a href="http://blog.sina.com.cn/s/blog_4caedc7a010184pl.html" target="_blank" rel="noopener">书写能够帮助我们更好地思考</a>，而且能够帮我们保持一致。而文档更加是跟踪整个项目的利器，有许多规格性的东西需要加以详细的描述，比如需求，技术要求，日程等等。文档是项目经理的法宝，项目经理的任务是促进软件开发团队的交流，而交流会减少我们之间的分歧以及误解。如果大家脑袋里的概念都是不同的，做出来东西也必定是不三不四。虽然可以保证设计人员很少，以保持文档的纯粹性，但是为了让编码人员最后实现的东西也和设计保持一致，文档是重要的，我们可以看到很多开源的项目都有自己的博客页面，以及很多的邮件列表。文档是为了更好地“交流”。</span></span></p>
<p></p>
<ul><li><span style="font-family:'Microsoft YaHei';font-size:14px;line-height:21px;color:#009900;">各种编程技术的使用——银弹在哪里？</span></li>
</ul>
<p></p>
<p><span style="font-family:''Microsoft YaHei'';"><span style="font-size:14px;line-height:21px;">银弹——杀死软件怪兽的武器在哪里？编程的技术一直在发展，新技术的发明使得软件生产率不断提高，不过少有工具能够将软件开发的生产率提高一个数量级。我们熟悉的高级语言、结构化程序设计、OOP、以及各种各样的框架都很大地提高了我们的软件生产率。而对于软件的最主要的矛盾——复杂度 来说，没有银弹可以杀死它，因为软件工程不能被可视化成我们能够体会到的三维表示，而且它对于人类来说的确太过于复杂了，必须要花费许许多多的人力和时间来完成。其中设计就是最困难的，我们不可能保证设计的每一处都能保持一致，因为很多时候封装抽象使得它被分配到很多人的手上，就算是在一个人的手上，也会有各种各样的差异。差的设计容易带来一堆的bug，而好的设计能够让程序良好地运行。就银弹而言，好像没有一种工具能够解决软件复杂度的问题，只是靠各种工具不断改善这一处境。但是我们在hack news 里面看到一个很神奇的开发工具居然可以实时调试，而且可视化，对于程序员来说更加方便有趣忘记叫什么名字了,毫无疑问，前途是光明的，我们天生就很乐观 ：）</span></span></p>
<p><span style="font-family:''Microsoft YaHei'';"><span style="font-size:14px;line-height:21px;">【after passage】</span></span></p>
<p><span style="font-family:''Microsoft YaHei'';"><span style="font-size:14px;line-height:21px;">软件工程是个大范围的东西，也许现在不到时候去深入了解这些东西，不过拿来读读还是不错的。毕竟我们还是以提升技术为主，没有技术根本无需去谈这些太大的概念。接下来就好好磨砺算法和数据结构，然后多编码练练手，等有一天能够用上人月的知识的时候，我会翻出这本书再看一遍。如果你也对这本书感兴趣，那么不妨到<a href="http://book.douban.com/subject/1102259/" target="_blank" rel="noopener">豆瓣这里</a>去看看其他人写的书评。</span></span></p>
<p><span style="font-family:''Microsoft YaHei'';"><span style="font-size:14px;line-height:21px;">by bibodeng &nbsp;April,27th,2012 &nbsp; Friday</span></span></p>
<p></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2012/04/24/编程的最低境界——徒手写排序/" itemprop="url">
                  编程的最低境界——徒手写排序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2012-04-24T08:13:51+08:00" content="2012-04-24">
              2012-04-24
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2012/04/24/编程的最低境界——徒手写排序/" class="leancloud_visitors" data-flag-title="编程的最低境界——徒手写排序">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
<p><strong><span style="font-family:&#39;comic sans ms&#39;;">【编程的最低境界】</span></strong><br></p><div><span style="font-family:&#39;comic sans ms&#39;;">自从学习了高级语言C/C++之后，接着就学习了一些简单的算法。最近看《算法导论》，又重新学习了一下之前的最最基础的算法——“排序”。排序虽然基础，能根据各种排序方法的思想徒手写出排序算法来，是编程的最低阶段，排序都写不好，就别谈开发好的软件了。虽然其他博客上到处都是排序的文章和代码，但是我觉得还是要写一写，记录下思考的过程，同时给自己动手的机会。有兴趣的同学可以翻翻《算法导论》17页的归并排序以及第二部分的第六章堆排序和第七章快速排序。</span></div><p><span style="font-family:&#39;comic sans ms&#39;;">&nbsp;</span></p><div><strong><span style="font-family:&#39;comic sans ms&#39;;">【排序的思想】</span></strong></div><p><span style="font-family:&#39;comic sans ms&#39;;">&nbsp;</span></p><div><span style="font-family:&#39;comic sans ms&#39;;">根据导论的说法，排序就是输入一组数据&nbsp;x1,x2,x3...xn,经过排序后能够输出x1&#39;,x2&#39;,x3&#39;...xn&#39;，且使得x1&#39;&lt;x2&#39;&lt;x3&#39;&lt;...&lt;xn&#39;(当然也可以逆序过来)。数据的表现形式就是编程的根本，数据以有序的形式表现出来就是排序的使命。然而对于排序算法，有非常多的思想：</span></div><p><span style="font-family:&#39;comic sans ms&#39;;">&nbsp;</span></p><div><span style="font-family:&#39;comic sans ms&#39;;">1、插入排序</span></div><div><span style="font-family:&#39;comic sans ms&#39;;">2、选择排序</span></div><div><span style="font-family:&#39;comic sans ms&#39;;">3、冒泡排序（类似插入排序）</span></div><div><span style="font-family:&#39;comic sans ms&#39;;">4、希尔排序</span></div><div><span style="font-family:&#39;comic sans ms&#39;;">5、归并排序</span></div><div><span style="font-family:&#39;comic sans ms&#39;;">6、快速排序</span></div><div><span style="font-family:&#39;comic sans ms&#39;;">7、堆排序（利用堆数据结构的性质）</span></div><div><span style="font-family:&#39;comic sans ms&#39;;">8、还有其他基于数据分布的排序（基数排序、桶排序等等）</span></div><div><br></div><div><strong><span style="font-family:&#39;comic sans ms&#39;;">【插入和冒泡排序】</span></strong></div><p><span style="font-family:&#39;comic sans ms&#39;;">&nbsp;</span></p><div><p><span style="font-family:&#39;comic sans ms&#39;;">插入排序容易理解，就是一趟遍历一次尚未排序的元素插入到已经排序的序列中，如此进行一次则可以将一个元素放到已排序序列中，从第二个元素开始循环N-1次（N为元素个数）即可得到一个全部有序的序列。此算法的复杂度是O（N^2）,因为一个元素最多需要与其他元素交换的次数是n-1次，而一般是小于这个数的，然后外循环算一个n，则得到其复杂度不超过N^2.在样本数N小的情况下，插入排序是十分迅速的。</span></p><p>&nbsp;</p><pre class="brush:cpp; toolbar:true; auto-links:true;">void insertSort(int a[],int size)
{
	int j = 0;
	int i = 0;
	for(i=1;i&lt;size;i++)
	{
		j=i;
		while(j&gt;0 &amp;&amp; a[j]&lt;a[j-1])
		{
			swap(a[j],a[j-1]);
			j--;
		}
	}
	cout &lt;&lt; "insertsort end " &lt;&lt;endl;
}</pre><p><span style="font-family:&#39;comic sans ms&#39;;">swap&nbsp;函数是交换两个参数的值。可以看到从i=1(数组中的第二个元素)开始，我们就从i往前查找，如果有比a[j]大的，则a[j]作为小的，要往前排。这样就可以将a[j]插入到有序序列中，同时插入后依然保持有序数列特性，同时i往后移动一步，继续排序后面的元素。</span></p><p><span style="font-family:&#39;comic sans ms&#39;;">可见这个排序的思想是非常直观的，写代码的时候只要记住，两个循环，把元素i往前面排，一路交换下去，就能得到有序序列了。我想任何CS的同学都能够在三分钟之内写出这几行代码来吧，这是编程的最低境界，没得说必须熟练。</span></p><p><span style="font-family:&#39;comic sans ms&#39;;">冒泡排序的思想是，就像一个气泡往上浮起，自然相同体积的水要和气泡进行空间交换，而排序的主要步骤是，一趟循环，将相邻两个元素进行比较，大的往下沉，小的往上浮（即交换），这样每一趟的最后，最大的一个肯定是在最底下了。如此经过N趟，则会形成一个从小到大的序列。</span></p><p><span style="font-family:&#39;comic sans ms&#39;;">【归并排序】</span></p><p><span style="font-family:&#39;comic sans ms&#39;;">归并排序的思想源于将两组东西合并起来，大家玩扑克牌的时候经常需要将两叠牌进行排序，于是左手抽一张牌，右手抽一张牌，那个小，先出哪张，如果左手的出了，就再用左手抽一张牌，再看看左右手的牌，出小的，如果是右手的出了，右手抽牌，比较。。。按照这种思想，到最后一定会是按从小到大的顺序出牌的。下面给出代码：</span></p><p>&nbsp;</p><pre class="brush:cpp; toolbar:true; auto-links:true;">//-----------------------mergesort------------------------------------------------
void mergeSort(int a[],int left,int right)
{
	if(left&lt;right)
	{
		int mid = (left+right)/2;
		mergeSort(a,left,mid);
		mergeSort(a,mid+1,right);

		int *b = new int[right-left+1];
		merge(a,b,left,mid,right);         //merge a into b 
	}
}


void merge(int a[],int b[],int left,int mid,int right) //high grade merge algorithm
{
	//put the result into the arr b ,then copy it back to a
	int size = right-left +1; //calculate the size 
	int *pl = &amp;a[left];
	int *pr = &amp;a[mid+1];
	//int *pb = &amp;b[0];
	int offset =0;
	while(offset &lt; size)
	{	
		if(pl&gt;&amp;a[mid]&amp;&amp;pr&lt;=&amp;a[right])	//copy right part into b[]
		{
			b[offset++] = *pr++;
		}

		else if(pr&gt;&amp;a[right]&amp;&amp;pl&lt;=&amp;a[mid])	  //copy left part into b[]
		{
			b[offset++] = *pl++;
		}
		else 
		{
			if(*pl&lt;*pr)
				b[offset++] = *pl++;
			else
				b[offset++] = *pr++;
		}
	
	}
		copy(a,b,left,right,size); //copy b[] back to a[] from left to right
		
}

void copy(int a[],int b[],int left,int right,int size)
{
	int *pa = &amp;a[left];    //destination
	int *pb = &amp;b[0]; //source

	int tmpoffset=0;
	while(tmpoffset &lt;size)
	{
		*pa++ = *pb++;
		tmpoffset ++;
	}
}</pre><p><span style="font-family:&#39;comic sans ms&#39;;">归并排序有一个缺点就是需要另外一个O（N）的空间消耗，最终得到的结果需要复制回去原来的数组中去。归并排序的算法复杂度是O（NlgN）的，画一棵树会比较容易理解其涵义。因为我们对数组进行分半，然后最后肯定是有lgN，然后递归下去，最后进行了lgN次的分半，然后归并的过程是用了N的时间，故而最终时间复杂度是O（NlgN）.&nbsp;归并非常有趣的一点就是用到了递归，先对数组进行分半，然后递归对左半边进行归并排序，对右半边进行排序，最后合并起来。这样的方法启发我们，要善于在处理数据中抽象出特征方法，这就是分治的思想，而且使用了递归的思想，用同一种办法化大为小，然后利用程序调用的无形的“栈”一层层地返回合并的结果。话说系统子程序调用的无形的“栈”还有反转字符串的作用。不信可以看下面的代码：</span></p><p>&nbsp;</p><pre class="brush:cpp; toolbar:true; auto-links:true;">#include "stdio.h"
void Print(void);
int main()
{
	printf("please input string and end with # \n");
	Print();
	getchar();
}

void Print(void)
{
	char a;
	scanf("%c",&amp;a);
	if(a != '#') Print();
	printf("%c",a);
}</pre><p><span style="font-family:&#39;comic sans ms&#39;;">进入主函数，调用print，输入数据，再调用自身，输入数据，直到最后一层调用，输出最新输入数据，返回上层，输出倒数第二数据，这样一层层地返回，就将字符串反转过来了。就像用了一个栈一样，不断地压入数据，再一一弹出，得到反转顺序的序列。当然，这是别的话题了。下面接着看快速排序。</span></p><p><strong><span style="font-family:&#39;comic sans ms&#39;;">【快速排序】</span></strong></p><p><span style="font-family:&#39;comic sans ms&#39;;">快速排序，那是相当地快。那是因为它在平均的情况下复杂度是O（NlgN）,虽然最坏情况下是O（N^2）的，但毕竟那是最坏情况（序列已经有序），一般来说很少出现这样的情况，为了避免partition的不均匀，故而采用随机化的qsort是很不错的主意。这样作为partition的依据一般是随机选择的，故而依照概率不会发生每次都只将序列分为一个为1，另外一个是N-1个元素（这是很糟糕的）。还是来看看代码吧：</span></p><p>&nbsp;</p><pre class="brush:cpp; toolbar:true; auto-links:true;">void qSort(int a[],int p,int r)
{
	
	if(p&lt;r)
	{
		int q = partition(a,p,r);
		qSort(a,p,q-1); //divide and conquer
		qSort(a,q+1,r); //递归调用
	}

}

//下面是重点partition
int partition(int a[],int p,int r) 
{
	int i=p;   //首
	int j=r+1;   //尾
	
	int x=a[p]; //基准元素

	while(1)
	{
		while(a[++i]&lt;=x &amp;&amp; i&lt;r)//i从首到尾，如果小于则i往后移
			;
		while(a[--j]&gt;x)  //j从尾部递减，如果大于则往前移
			;
		if(i&gt;=j)       //这里停止partition，跳出到括号外
			break;
		swap(a[i],a[j]); 

	}
	a[p] = a[j];  
	a[j] =x;   //基准元素必定在中间
	return j;
}</pre><p><span style="font-family:&#39;comic sans ms&#39;;">由代码可以知道，核心部分是partition，在数组的头尾设两个指针，前指针往后移动，后指针往前移动。在排序过程中，默认i所指位置之前的元素都小于或等于x（x为基准元素），而j所指之后的元素皆大于等于x。这样两个while（a[i++]&lt;=x&nbsp;&amp;&amp;&nbsp;i&lt;r）和while（a[j--]&gt;x）就不难理解了。重要的在后面，要是有元素不满足这个断言，那么就要将这两个元素互换了。一是大于x的，一个是小于x的，刚好进行互换，如果i和j交叉了，说明排序完成了，需要将基准元素插到它改到的位置（两组数据的中间）。这样就大功告成了！&nbsp;当然也可以换一种写法，不从尾部开始，而是两个指针都从数组首部开始，一直往后移动。</span></p><p>&nbsp;</p><pre class="brush:cpp; toolbar:true; auto-links:true;">void partition(int a[],int p,int r)
{
    int x = a[r]; //尾部元素做为分组依据
    int i = p-1;
    for(int j=p;j&lt;r;j++)
    {
      if(a[j]&lt;=x)
     {
       i = i+1;         //扩充小于或等于x的部分</pre><pre class="brush:cpp; toolbar:true; auto-links:true;">swap(a[i],a[j]);  //将a[j]进行挪动到小于或等于x的部分</pre><pre class="brush:cpp; toolbar:true; auto-links:true;">     }
    }
    return i+1; //返回数组的中间位置
}</pre><span style="font-family:&#39;comic sans ms&#39;;">原理上是一样的，只不过简化了代码，j查找的是小于等于x的最靠左的元素，找到之后则将现在所指的小于等于x的最靠右的元素的下一个位置进行交换，等于扩充了小于等于x的部分，到最后将会把基准元素与i+1位置的元素交换，返回的是数组的中间i+1位置。</span><p><strong><span style="font-family:&#39;comic sans ms&#39;;">【堆排序】</span></strong></p><p><span style="font-family:&#39;comic sans ms&#39;;">bibo写到这里已经筋疲力尽了，想必读者看到这里也是倾注了很大的耐心。对于那些代码，最好的办法就是自己敲一遍，然后跟着单步运行一次，慢慢地也就了解其中的思想，也熟练了一些技巧了。算法是一种技巧，搭载的是数学的思想，再经过实践者的手，变成可以用的工具。</span></p><p><span style="font-family:&#39;comic sans ms&#39;;">言归正传，堆——分为最大堆，最小堆，指的是堆的树结构中，位于根节点的元素是最大的还是最小的。最大堆，其根节点就是这棵树的最大值。而堆排序就是要利用这个特性，来实现每次都找出一个“最大”或“最小”元素来，放到树外面。其实由于堆是一颗完全二叉树，故而它能够存储在一个数组里面（做回忆状：数据结构课程里关于完全二叉树的存储，的确是可以存放到一个数组里面的）。而那些出了堆的元素，恰好能放回去数组中的某个位置，于是等全部元素都选过一遍之后，该数组就会呈现出一个有序状态。</span></p><p><span style="font-family:&#39;comic sans ms&#39;;">假设有这样一个样本存储在只有三个节点的堆里面：</span></p><p><span style="font-family:&#39;comic sans ms&#39;;">3&nbsp;，1&nbsp;，2</span></p><p><span style="font-family:&#39;comic sans ms&#39;;">其中0号位置的3，就是堆的根，好了，第一次查找，3出堆，通过整形2成为了根，1为2的孩子。这样腾出一个空间给3，这样3就在数组的最后了。</span></p><p><span style="font-family:&#39;comic sans ms&#39;;">同理，2出堆到位置1，结果1成为了堆根。现在的数组状态是：&nbsp;1&nbsp;&nbsp;2&nbsp;3</span></p><p><span style="font-family:&#39;comic sans ms&#39;;">此时数组状态是：1，2，3&nbsp;（没骗人，真的是有序的）</span></p><p><span style="font-family:&#39;comic sans ms&#39;;">安装这个方法同样也能定义出一个最小堆，得到有序序列&nbsp;：&nbsp;3，2，1。</span></p><p><span style="font-family:&#39;comic sans ms&#39;;">这就是堆排序的思想，下面是代码：</span></p><p>&nbsp;</p><pre class="brush:cpp; toolbar:true; auto-links:true;">//-----------------------------------------------------------------------

void heapSort(int a[],int size)
{
	int heapSize = size;  //heapSize was init to be the length of the array
	buildMaxHeap(a,heapSize); //build a heap on a[]
	for(int i=heapSize;i&gt;0;i--)
	{
		swap(a[0],a[i]); //swap the root of tree with the final element ,get out of the heap
		heapSize --;
		maxHeapify(a,0,heapSize); //重新整队，保持最大堆的性质
	}
}

void buildMaxHeap(int a[],int size)
{
	int heapSize = size; //initial the heapSize as the length of array a
	for(int k=(size-1)/2;k&gt;=0;k--)  //从不是叶子节点开始，一直往根上刨
	{
		maxHeapify(a,k,heapSize);   //进行建堆，就是让所有节点都符合堆的定义 ——根节点都要比子节点大
	}
}

void maxHeapify(int a[],int i,int heapSize)
{
	int left =( i&lt;&lt;1)+1;     //left child
	int right = (i&lt;&lt;1) +2; //right chlid position
	int largest =i; //mark the position of the largest element in array
	if(left &lt;=heapSize &amp;&amp; a[left] &gt; a[i])
		largest = left;
	else
		largest = i;

	if(right &lt;= heapSize &amp;&amp; a[right] &gt; a[largest])
		largest = right;
	
	if(largest != i) //说明有节点比根节点大，根节点需要下移
	{
		swap(a[i],a[largest]);//swap 之后都要整队
		maxHeapify(a,largest,heapSize);    //递归调用，防止子节点亦违反规则
	}
}</pre><p><span style="font-family:&#39;comic sans ms&#39;;">一开始的堆，不是说是就是的，而是要通过建堆操作来实现的。现在我们建一个最大堆，根据最小堆的定义，我们只需要保证根是最小的就行了，当然因为二叉树的递归结构，能够保证最上面的根是整个堆中最大的（哥们要的东西有了保障）。</span></p><p><span style="font-family:&#39;comic sans ms&#39;;">buildMaxHeap就是建立最大堆，这里需要说明的是存储在数组中的二叉完全树有两个和巧妙的特性，之所以巧妙，是因为可以轻易计算出哪个是根的左孩子，那个是根的右孩子，也能计算出最后一个非叶子节点，然后方便从非叶子节点做maxHeapify。</span></p><p><span style="font-family:&#39;comic sans ms&#39;;">如果你的数组是从0号开始存堆的，那么假设i为某个节点，那么i*2&nbsp;+&nbsp;1就左孩子所在位置，i*2&nbsp;+2&nbsp;乃右孩子所在位置，举个例子，0号的左孩子是1，右孩子是2。1号的左孩子是3，右孩子是4。可以画个图更加直观一点。</span></p><p>&nbsp;</p><p><a href="http://bibodeng.web-149.com/content/plugins/kl_album/upload/201204/0d308b19311b3cb29225783d44c3767b2012041812584213544.jpg" target="_blank"><img src="http://bibodeng.web-149.com/content/plugins/kl_album/upload/201204/0d308b19311b3cb29225783d44c3767b2012041812584213544.jpg" alt="点击查看原图" width="480" height="360" border="0"></a></p><p>&nbsp;</p><div class="codediv"><br><p><span style="font-family:&#39;comic sans ms&#39;;">好了，接下来就研究一下，怎样进行整堆吧，以为这是关键。看代码可知，查找该树中的最大值，然后将最大的作为堆的根。如此递归下去，这样每个带孩子的节点都将符合最大堆的定义。代码还是要好好研究一番的，如果思考十分钟，应该都能写出来吧。</span></p><p><strong><span style="font-family:&#39;comic sans ms&#39;;">【排序之后】</span></strong></p><p><span style="font-family:&#39;comic sans ms&#39;;">排序算法有很多，能徒手写出来，在算法上就已经进了一阶了。学习了排序之后，将会有更加复杂和困难的问题等待着我们，比如动态规划和贪心算法、回溯等等。我居然有耐心写完这一整篇了，那么也更加有信心去写接下来的高级算法。排序之后，我们需要的是重温一下学习的分治和递归思想，同时也动手练习（经验教训告诉我们，程序员是练出来的），接下来就是畅游算法的奇妙世界了。</span></p></div></div><p><span style="font-family:&#39;comic sans ms&#39;;">&nbsp;</span></p><div><span style="font-family:&#39;comic sans ms&#39;;">by&nbsp;bibodeng&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2012-04-18</span></div><p><a href="http://bibodeng.web-149.com/?post=26" target="_blank" rel="noopener">&nbsp;</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2012/04/24/从装配线到DNA比对——神器动态规划/" itemprop="url">
                  从装配线到DNA比对——神器动态规划
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2012-04-24T08:08:11+08:00" content="2012-04-24">
              2012-04-24
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2012/04/24/从装配线到DNA比对——神器动态规划/" class="leancloud_visitors" data-flag-title="从装配线到DNA比对——神器动态规划">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
<div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">【前言】</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">对于一个问题，我们如果可以枚举所有的解，那么这个解空间我们是知道的。那么如何在解空间里面找到最优解呢？这时有一个非常好的方法，从底向上地构造整个解，而每一步都是从地层寻求最优解，这样就能保证在最终得到的一定是最优解。这就是最优子结构，有这种结构的问题，通常都可以用动态规划的办法来寻求最优解。而且它是从小规模（子问题）到大规模问题的构造，而常常这样的解法能够用一张表直观地表现出来。表中的元素是一个表达式的某个特定值，这个表达式表现的是问题和子问题的关系，也就是如何在子问题中的解中寻找最优的关系，这样的关系在例子中会非常地明了。</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">&nbsp;</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">【装配流水线】</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;&#39;, &#39;microsoft yahei&#39;, &#39;&#39;"><span style="font-size:14px">&nbsp;</span></span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">往往最经典的算法书里面都会讲最经典的“装配流水线”问题。因为它相对来说比较简单，一个问题，只有两个个子问题，那就是两条流水线选哪条路径。即使是最简单的例子也会有一大通的表达式搞得头有点晕，不过多看几遍应该是可以克服的。</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">假设一个工厂有两条装配线：装配线0&nbsp;和&nbsp;装配线1&nbsp;，这两个装配线中有相同数量的装配站用于装配元件。</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">可以用下面的图表示两个装配站：</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">&nbsp;</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">&nbsp;</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">可以用S</span><sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">i,j&nbsp;</span></sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">表示第i条装配线（i&nbsp;为0或1）的第j个装配站。从一个装配线转移到另一个装配线的下一站需要消耗时间T</span><sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">i,j</span></sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">,例如从第一条线的第一站到第二条线的下一站（即第二站）所用的时间为T</span><sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">1,1</span></sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">。表明是从一线一站出发，而不用标记下一站是几，因为下一战一定是另一条线的j+1站。我们可以选择第一条线还是第二条线，来使得最终出线的时候，用时最短。</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">可能用语言表达很混乱，那么就用图像说明一下这些符号吧：</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">&nbsp;<a href="http://bibodeng.web-149.com/content/plugins/kl_album/upload/201204/234bfc7a97210c63f4c59cafe1cb98bc201204211514312340.jpg" target="_blank"><img src="http://bibodeng.web-149.com/content/plugins/kl_album/upload/201204/234bfc7a97210c63f4c59cafe1cb98bc201204211514312340.jpg" alt="点击查看原图" width="480" height="360" border="0"></a></span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">&nbsp;</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px"><span style="color:#009900">对于动态规划的解法，有一个可以遵循的套路</span>：</span></div><ol style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><li><p><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">理清楚是怎样获得最短用时的（最优解），这里是两条线，可以选择，要求最后用时最短</span></p></li><li><p><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">用递归来表示解的通式</span></p></li><li><p><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">计算（比较）得到最短时间（如何从两条线中选取）</span></p></li><li><p><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">回溯得到这条路径</span></p></li></ol><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">什么也不说了，先找出最重要的递归式，然后填表：</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">&nbsp;</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">F</span><sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">最短用时&nbsp;</span></sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">=&nbsp;min(F</span><sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">0</span></sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">[n])+x1,&nbsp;F</span><sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">1</span></sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">[n]+x2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x0,x1&nbsp;表示最后一站到终点用时，F</span><sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">i</span></sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">[n]表示第i条线的第n站。&nbsp;比较最终谁用时最短</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">&nbsp;</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">F</span><sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">1</span></sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">[j]&nbsp;=&nbsp;&nbsp;min(F</span><sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">0</span></sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">[j-1]+a</span><sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">0,j&nbsp;</span></sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">&nbsp;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F</span><sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">1</span></sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">[j-1]&nbsp;+&nbsp;t</span><sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">1,j-1&nbsp;</span></sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">+&nbsp;a</span><sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">0,j</span></sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表示到1线j站的最短时间是上一站是一线直接过来的，要么就是二线转移过来的，转移的时候付出的代价是t</span><sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">1,j-1。</span></sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">对于二线的时候是一样的</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">F</span><sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">1</span></sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">[j]&nbsp;=&nbsp;&nbsp;min(F</span><sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">1</span></sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">[j-1]+a</span><sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">1,j&nbsp;</span></sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">&nbsp;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F</span><sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">0</span></sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">[j-1]&nbsp;+&nbsp;t</span><sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">0,j-1&nbsp;</span></sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">+&nbsp;a</span><sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">1,j</span></sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-----------------------------1</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">&nbsp;</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">而F</span><sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">i</span></sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">[j]&nbsp;比较特殊，因为一开始只能从一条路径进入，用时为e</span><sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">i&nbsp;</span></sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">(i&nbsp;为0或1)</span></div><p style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;margin:5px 0px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">F</span><sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">i</span></sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">[0]&nbsp;=&nbsp;e</span><sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">i&nbsp;</span></sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">+&nbsp;a</span><sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">i,0</span></sub><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-----------------------------2</span></p><p style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;margin:5px 0px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">在这里，我直接将ei也计入了第0个站中，因为进站和出站是不能换线的。</span></p><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">这样1式和2式，共同表达了一个递归关系，其含义也不难理解。</span><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">下面用底向上方法构造一条路径，动态规划很多时候是先用某种方法求得那种是最好的，再回溯把该路径求出来。</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">先给出填表算法：</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;&#39;, &#39;microsoft yahei&#39;, &#39;&#39;"><span style="font-family:&#39;&#39;, &#39;microsoft yahei&#39;, &#39;&#39;"><span style="font-size:14px">&nbsp;</span></span></span><pre class="brush:cpp; toolbar:true; auto-links:false;">void findWay(int *a[],int *t[],int *line[],int &amp;finalLine,int n) //n 个站点
{
	int **f = new int*[2];
	for(int k=0;k&lt;2;k++)//总共有两条流水线，流水线0 和流水线 1
	{
		f[k] = new int[n];
	}
	f[0][0] = a[0][0];  
	f[1][0] = a[1][0];  

	for(int i=1;i&lt;n;i++)   //从站点1开始到第n-1个站点
	{
		if(f[0][i-1]+a[0][i] &lt;= f[1][i-1]+t[1][i-1] + a[0][i] )                //line zero	其实可以去掉共同部分a[0][i]
		{
			f[0][i] = f[0][i-1] + a[0][i];   
			line[0][i] = 0;
		}
		else
		{
			f[0][i] = f[1][i-1] + t[1][i-1] + a[0][i];
			line[0][i] = 1;
		}


		if(f[1][i-1] + a[1][i] &lt;= f[0][i-1] + t[0][i-1] + a[1][i])			//line one
		{
			f[1][i] = f[1][i-1] + a[1][i] ;
			line[1][i] = 1;
		}
		else
		{
			f[1][i] = f[0][i-1] + t[0][i-1] + a[1][i];
			line[1][i] = 0;
		}
	}

	if(f[0][n-1] &lt;=  f[1][n-1])
	{
		finalLine = 0; 
	}
	else
	{
		 finalLine = 1;
	}
}</pre></div><p style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;margin:5px 0px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">然后再给出递归调用的回溯（利用填表的过程中记录的路径），得到顺序的解：</span></p><p style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;margin:5px 0px;">&nbsp;</p><pre class="brush:cpp; toolbar:true; auto-links:true;">void printStations(int *line[],int finalLine,int n)   //递归输出经过的站点
{
	int i = finalLine;
	int j = n-1;
	if(j&gt;0)
	printStations(line,line[i][j],j);    //递归产生顺序路径

	cout &lt;&lt;"装配线"&lt;&lt; i &lt;&lt; "装配站"&lt;&lt;j&lt;&lt;endl;
}</pre><p>&nbsp;</p><p style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;margin:5px 0px;">&nbsp;</p><p style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;margin:5px 0px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">假设有一个用例数据如上面的图片所示。则调用主函数</span></p><p style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;margin:5px 0px;">&nbsp;</p><pre class="brush:cpp; toolbar:true; auto-links:true;">void main()
{
	int n = 0;
	int k = 0;			//k and g用于循环子
	int g = 0; 
	int e0 =0;			//enter
	int e1 =0;
	int x0 = 0;		//exit
	int x1 = 0;
	cout &lt;&lt;"总共有2条相同站点的装配线，请输入装配线的站点数 ： "&lt;&lt;endl;
	cin&gt;&gt; n;       

	cout &lt;&lt;"请输入进入装配线0,1的时间花费： "&lt;&lt;endl;
	cin&gt;&gt; e0 &gt;&gt; e1;     

	cout &lt;&lt;"请输入退出装配线0,1的时间花费： "&lt;&lt;endl;
	cin&gt;&gt; x0 &gt;&gt; x1;    
	
	int **a = new int*[2];      //站点花费时间
   int **t = new int*[2];       //换线花费时间
	int **line = new int*[2];   //记录路线轨迹

	for(k=0;k&lt;2;k++)			//总共有两条流水线，流水线0 和流水线 1
	{
		a[k]  = new int[n];        //n个站点的流水线
		t[k] = new int[n];			//n个站点之间的交叉路线花费时间——换线时间
		line[k] = new int[n];		 //用于记录路径
	}
		

	//------------------------------------装配时间----------------------------------------
	cout &lt;&lt;"请输入进入站点以及在站点内装配的时间"&lt;&lt;endl;
	for( k=0;k&lt;2;k++)
	{
		for(g=0;g&lt;n;g++)
		{
			cout &lt;&lt;"\n输入装配线"&lt;&lt;k&lt;&lt;"的第"&lt;&lt;g&lt;&lt;"个站点所花费的时间 : ";
			cin &gt;&gt; a[k][g];
		}
	}
	a[0][0] += e0;			//将进入时间花费和第0号站点绑定
	a[0][n-1] += x0;		//将出线时间花费和第n-1号站点绑定 今后不用计算
	a[1][0] += e1;
	a[1][n-1] +=x1;   

	//------------------------------换线时间------------------------------------------------
   for( k=0;k&lt;2;k++)
	{
		for(g=0;g&lt;n-1;g++)
		{
			cout &lt;&lt;"\n输入装配线"&lt;&lt;k&lt;&lt;"的"&lt;&lt;g&lt;&lt;"站到另一条线的"&lt;&lt;g+1&lt;&lt;"站点所花费的时间 : ";
			cin &gt;&gt; t[k][g];
		}
	}
   cout &lt;&lt; endl;

   int finalLine = 0;  //初始化
   findWay(a,t,line,finalLine,n);  //动态规划查找路径
   printStations(line,finalLine,n);  //打印路径
   system("pause");
}</pre><p>&nbsp;</p><p style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;margin:5px 0px;">&nbsp;</p><p style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;margin:5px 0px;">&nbsp;</p><p style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;margin:5px 0px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">那么结果是</span></p><p style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;margin:5px 0px;"><img id="WizImageID" src="../admin/ueditor/themes/default/images/spacer.gif" align="middle" border="0" word_img="file:///C:/Users/bibodeng/AppData/Local/Temp/Wiz/c9a1fbb9-a25c-446a-a2ea-5972c6480774_1_files/13888031.png" style="background:url(../admin/ueditor/themes/default/images/localimage.png) no-repeat center center;border:1px solid #ddd"></p><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">&nbsp;</span><img id="WizImageID" src="../admin/ueditor/themes/default/images/spacer.gif" align="middle" border="0" word_img="file:///C:/Users/bibodeng/AppData/Local/Temp/Wiz/c9a1fbb9-a25c-446a-a2ea-5972c6480774_0_files/13888031.png" style="background:url(../admin/ueditor/themes/default/images/localimage.png) no-repeat center center;border:1px solid #ddd"><a href="http://bibodeng.web-149.com/content/plugins/kl_album/upload/201204/4548ab6b8b99ab3fba033f1566146ea2201204211516393213.png" target="_blank"><img src="http://bibodeng.web-149.com/content/plugins/kl_album/upload/201204/4548ab6b8b99ab3fba033f1566146ea2201204211516393213.png" alt="点击查看原图" width="379" height="121" border="0"></a></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">【装配线的小结】</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">装配线问题的解空间比较小，故算法比较快就完成了求用时最少的路径。重要的是求解的过程有一个套路。那就是求递归表达式——&gt;根据递归式填表——&gt;回溯求得解路径。接下来就过渡到一个比较难一点的问题——DNA序列检测，就原理上来讲是万变不离其宗。</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">&nbsp;</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">&nbsp;</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">【DNA序列比对】</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">由于DNA序列十分庞大，故而需要非常大的内存空间来存储这个字符串，然而真正能用的软件是不可能无节制地使用内存，用来比对相对较短的序列还行。</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">要比对DNA的相似度最大的子串，则必须要有一种机制来评价怎样最大，因而选取一种计分的方法来评定两个字符串的相似度，越相似的得分越高。具体的评分标准是这样的，至于为什么是这样很有必要思考一下：</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">1、匹配一个得5分</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">2、不匹配一个扣1分</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">3、无法匹配（需要插入空格）扣掉2分&nbsp;&nbsp;&nbsp;</span></div><p style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;margin:5px 0px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">&nbsp;<a href="http://bibodeng.web-149.com/content/plugins/kl_album/upload/201204/b4db723a36ec8a06e618abdb54ea2acc201204211525423667.png" target="_blank"><img src="http://bibodeng.web-149.com/content/plugins/kl_album/upload/201204/b4db723a36ec8a06e618abdb54ea2acc201204211525423667.png" alt="点击查看原图" width="480" height="246" border="0"></a></span></p><p style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;margin:5px 0px;"><span style="font-size:14px;font-family:&#39;microsoft yahei&#39;">其递归意义就是在三种情况中选最大值，max&nbsp;应该在大括号前面，这里图片没有画好。</span></p><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">比较难理解的是无法匹配的情况，举个例子就比较好说明了</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">假如有一个DNA串为&nbsp;GTAC</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">而另外一个字符串为&nbsp;&nbsp;GAC</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">显然一一对应的时候（最后插入一个空格）得分是不高的，只有1分</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">而在第二个字符的前面插入一个空格，得到G_AC&nbsp;这样得分为13分，高吧？</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">所以，就要考虑在哪里插入空格的复杂问题。</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">为了想清楚这个问题，还是用填表的方法比较直观发现问题。</span><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">我们每次比对总是选取一个得分最高的方案，这个方案可能是串S1插入一个空格，或者是S2插入一个空格，或者进行比匹配了，或者进行比对不匹配。对于那些长度不想等的两个字符串，总要填入&nbsp;|s1.length()&nbsp;-&nbsp;s2.length()|个空格。于是先将第0行和第0列填成&nbsp;-2&nbsp;*&nbsp;i&nbsp;和&nbsp;-2*j&nbsp;(这里i和j分别对于行和列的索引)。</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">&nbsp;</span><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">这样，每次计算要求a[i-1][j-1],a[i-1][j],a[i][j-1]这三个元素要先填好。于是我们就用从i=1，j=1&nbsp;一行行填的办法可以满足这个条件。最终能够得到这样一幅图：</span></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><img src="../admin/ueditor/themes/default/images/spacer.gif" border="0" word_img="file:///C:/Users/bibodeng/AppData/Local/Temp/Wiz/8725437.png" style="background:url(../admin/ueditor/themes/default/images/localimage.png) no-repeat center center;border:1px solid #ddd"></div><p style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;margin:5px 0px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">&nbsp;<a href="http://bibodeng.web-149.com/content/plugins/kl_album/upload/201204/0c159b34f779c5628240a3058f949a902012042115203932322.png" target="_blank"><img src="http://bibodeng.web-149.com/content/plugins/kl_album/upload/201204/0c159b34f779c5628240a3058f949a902012042115203932322.png" alt="点击查看原图" width="424" height="312" border="0"></a></span></p><p style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;margin:5px 0px;">&nbsp;</p><pre class="brush:cpp; toolbar:true; auto-links:true;">void dynamic_programming(int *a[],const string &amp;s1,const string &amp;s2)
{
	//initial the array 
	for(unsigned int k=0;k&lt;=s1.length();k++)//the first colunm
	{
		a[k][0] = INDEL*k;
	}
	for(unsigned int g=0;g&lt;=s2.length();g++)
	{
		a[0][g] = INDEL*g;
	}
	//next step: fill the table
	for(unsigned int i=1;i&lt;=s1.length();i++)//row
	{
		for(unsigned int j=1;j&lt;=s2.length();j++)//col
		{
			int tmp1 = 0;
			int tmp2 = 0;
			int tmp3 = 0;
			tmp1 = a[i-1][j-1] + isMatch(s1[i-1],s2[j-1]);
			tmp2 = a[i-1][j] + INDEL;
			tmp3 = a[i][j-1] + INDEL; 
			a[i][j] = max(tmp1,tmp2,tmp3);
		}
	}

	for(unsigned int r=0;r&lt;=s1.length();r++)//row
	{
		for(unsigned int s=0;s&lt;=s2.length();s++)//col
		{
				cout &lt;&lt;setw(4)&lt;&lt; a[r][s] ;
		}
		cout &lt;&lt; endl;
	}
}

int max(const int &amp;a,const int &amp;b,const int &amp;c)
{
	if(a &gt; b)
	{
		if(a &gt; c)
			return a;
		else
			return c;
	}
	else // a&lt;b
	{
		if(b &gt; c)
			return b;
		else
			 return c;
	}
}</pre><pre class="brush:cpp; toolbar:true; auto-links:true;">int isMatch(char ch1,char ch2)
{
	if(ch1 == ch2)
		return MATCH;
	else 
		return MISMATCH;
}</pre><p style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;margin:5px 0px;">&nbsp;</p><p style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;margin:5px 0px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">&nbsp;其中用到了一个求三个数的最大值的子函数</span></p><p style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;margin:5px 0px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">&nbsp;</span></p><p style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;margin:5px 0px;">&nbsp;</p><p style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;margin:5px 0px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">接下来就回溯，一一检测递归表达式中的三种情况，然后在结果中进行相应的操作.</span><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">如果匹配或者不匹配，放入结果串中。</span><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">如果需要插入空格，则插入空格，另外一个插入对应的S1[i]或者S2[j],因为是从对角线上找，所以一定是三种情况有且仅有一种。但是注意特殊情况，当到了i&nbsp;=&nbsp;0&nbsp;或者j=0&nbsp;的时候，也就是说到了第零行或者第零列的时候，优先考虑遍历完所有两条DNA串，而不是插入空格。例如，在蓝色线上的3，虽然不匹配，但是a[1][0]那里刚好是3&nbsp;+&nbsp;5&nbsp;=&nbsp;-2，造成了误解。所以我们的计分方法也是可以商榷的。这里的解决办法是INDEL（插入空格）优先。</span></p><p style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;margin:5px 0px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px"><a href="http://bibodeng.web-149.com/content/plugins/kl_album/upload/201204/76945ab3a2c9961f9edaf89ab56434802012042115215714707.png" target="_blank"><img src="http://bibodeng.web-149.com/content/plugins/kl_album/upload/201204/76945ab3a2c9961f9edaf89ab56434802012042115215714707.png" alt="点击查看原图" width="340" height="249" border="0"></a><br></span></p><p style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;margin:5px 0px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">所有代码如下：</span></p><p style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;margin:5px 0px;">&nbsp;</p><pre class="brush:cpp; toolbar:true; auto-links:true;">void trace_back(int *a[],const string &amp;s1,const string &amp;s2)
{
	vector &lt;char&gt; ans1;
	vector &lt;char&gt; ans2;
	ans1.push_back(' ');
	ans2.push_back(' ');
	for(int i=s1.length(),j = s2.length();i&gt;0;)
	{
		
		 if(a[i][j] == a[i-1][j] + INDEL)
		{
			ans2.push_back('-');
			ans1.push_back(s1[i-1]);
			i--;
		}
		else if(a[i][j] == a[i][j-1] + INDEL)
		{
			ans1.push_back('-');
			ans2.push_back(s2[j-1]);
			j--;
		}
		else if(a[i][j] == a[i-1][j-1] + MATCH || a[i][j] == a[i-1][j-1]+MISMATCH) //这三个if else 语句，这条不能放到最先
		{ 
			ans1.push_back(s1[i-1]);
			ans2.push_back(s2[j-1]);
			i--;
			j--;
		}
	}

	cout &lt;&lt; endl;
	for(unsigned int i=ans1.size()-1 ;i&gt;0;i--)
		cout &lt;&lt; ans1.at(i);
	cout &lt;&lt;endl&lt;&lt; endl;
	for(unsigned int j=ans2.size()-1;j&gt;0;j--)
		cout &lt;&lt; ans2.at(j);
	cout &lt;&lt; endl;

	//finally print out the string
}</pre><p>&nbsp;</p><p style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;margin:5px 0px;">&nbsp;</p><p style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;margin:5px 0px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">主函数很简单，产生两个待传入的参数即可：</span></p><p style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;margin:5px 0px;">&nbsp;</p><pre class="brush:cpp; toolbar:true; auto-links:true;">#define INDEL -2    //insert an blank
#define MISMATCH -1  
#define MATCH  5

int main()
{
	string s2 ="AGTCCCC";
	string s1 ="ACGTATCC";
	//string s2 ="ACCGTGTCATGGGTCCACTTT";
	//string s1 ="ACAATGTTGGGTCGCTAT";
	/*string s1,s2;
	cin &gt;&gt; s1;
	cin &gt;&gt; s2;*/

	//apply a two degree matrix
	int **a = new int *[s1.length()+1]; //行			额外多一个空格
	for(unsigned int g=0;g&lt;s1.length()+1;g++)
		a[g] = new int[s2.length()+1];	//列		额外多一个空格

	//call the function to compute the score
	dynamic_programming(a, s1, s2); 
	trace_back(a, s1, s2);

	system("pause");
	return 0;
}</pre><p>&nbsp;</p><p style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;margin:5px 0px;">&nbsp;</p><pre class="brush:cpp; toolbar:true; auto-links:true;">如果传入的两个字符串是</pre><pre class="brush:cpp; toolbar:true; auto-links:true;"><span style="font-size:14px"><span style="color:#009900">//string&nbsp;s2&nbsp;=&quot;ACCGTGTCATGGGTCCACTTT&quot;;</span></span></pre><p style="margin:5px 0px;"><span style="font-size:14px;color:#009900">//string&nbsp;s1&nbsp;=&quot;ACAATGTTGGGTCGCTAT&quot;;</span></p><p style="margin:5px 0px;"><span style="font-size:14px">那么可以获得这样的解：</span></p><p style="margin:5px 0px;"><span style="font-size:14px;color:#003399">ACAATGT--TGGGTCG-CTAT</span></p><p style="margin:5px 0px;"><span style="font-size:14px;color:#003399">ACCGTGTCATGGGTCCACTTT</span></p><p style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;margin:5px 0px;">&nbsp;</p><p style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;margin:5px 0px;">&nbsp;</p><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><p style="margin:5px 0px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">【小结】</span></p><p style="margin:5px 0px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">动态规划算法复杂度是O(N<sup>2)，</sup>从装配线到DNA序列比对，动态规划算法都表现得十分完美，总是返回给我们一个最优的解。而我们也不得不佩服算法的伟大，在现实的生活中无处不在，改变着我们的世界。动态规划算法是一项高级技术，很多书本上还有许多例子，如子串问题，矩阵连乘等问题（矩阵的运算是计算机都不能承受之重，能减少一点负担是一点）。在我看来，动态规划最重要的还是找到递归式子，找准问题和子问题的关系。找到之后就能填表了，表填好了就可以回溯得到解了。</span></p><p style="margin:5px 0px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">&nbsp;</span></p></div><div style="font-family:&#39;sans serif&#39;, tahoma, verdana, helvetica;font-size:12px;line-height:18px;"><span style="font-family:&#39;microsoft yahei&#39;;font-size:14px">by&nbsp;bibodeng&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2012-04-21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原载于&nbsp;<a href="http://bibodeng.web-149.com/" target="_blank" rel="noopener">bibodeng&nbsp;think&nbsp;beyond</a></span></div>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2012/04/24/于混乱之中创造秩序——文件的自由/" itemprop="url">
                  于混乱之中创造秩序——文件的自由
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2012-04-24T07:41:09+08:00" content="2012-04-24">
              2012-04-24
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2012/04/24/于混乱之中创造秩序——文件的自由/" class="leancloud_visitors" data-flag-title="于混乱之中创造秩序——文件的自由">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
<p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">【篇首语】</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px;color:#00b050">自由并不是无拘无束任意妄为，而是在混乱之中创造秩序。</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">对于计算机的文件而言，其所遵守的秩序给我们带来了无比大的好处，让我们可以精确访问我们想要的文件，而且还能共享文件。操作系统的文件管理给我们很大的自由：可以读写执行文件，可以保护自己的文件，可以对文件分门别类，可以对文件创造链接，和别人共享文件。就无比庞大的互联网，也是基于文件的共享的，这样我们才能从此机访问彼机的网页。然后，我们不仅仅要享受这来自不易的自由，也要知道自由从何而来！</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">【混沌的开始】</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">计算机的硬盘里面，是一堆夹杂着的0，1。没有谁知道里面到底蕴含着什么信息，然而，人类将他们用一些规则把这些01组织成为文件，那么这片magic土地，生长出了无限的生命。然而，接着我们要这一切变得有序而且方便查找，我们知道内存是有序的，那么怎样用小小的内存去寻找大大的硬盘中的文件呢？这就像拿着一张地图，去找想去的地方。我们可以对硬盘进行分割了，成了一些扇区，而文件就存储在这些扇区里面，而怎样才能找到文件所在的确定的扇区呢？这就需要在内存中维护一张文件和硬盘地址的对应关系表，这张表里还维护了文件的许多信息。其中对于一个文件有一个数据结构抽象了它，我们叫做FCB(文件控制块，和进程控制块是一个原理)，这个数据结构里面存储了文件的名字，类型，大小，创建日期，以及各种读写权限等信息。</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">有几种方法用来组织这张对应关系表，方便我们查找文件。</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">方法一：单级文件目录</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">将所有的文件统统罗列在一起，查找比较费时，而且不允许重名，不管是你的还是我的，都混在一起，不方便分享，不知道那个是你的哪个是我的。不利于插入和删除。</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">查找难度系数&nbsp;&nbsp;N</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px"><br></span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">方法二：两级文件目录</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">将各个用户的文件归到各自的目录下，从而更容易区分你我，也可以重名了。你有一个儿子叫小明，我有一个儿子叫小明，你家的是刘小明，我家的叫邓小明。而且查找比较容易了，你要找刘小明，你应该挨家挨户找，找到刘家，然后对刘家进行盘查，找到小明。相比叫所有人出来排好队（单级文件目录）一个个找少了很多工作。</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px"><br></span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">查找难度系数&nbsp;M&nbsp;+&nbsp;G&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;为分组数（多少人家），而G&nbsp;表示某个分组的目录项（一家有多少口人）。</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">方法三：树形文件目录</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">树形文件目录用树数据结构来组织文件和目录。这就是我们可以在windows的资源管理器中看到的树形目录，一个目录下可能有很多子目录和一些叶子节点（即文件），这样其从属关系就十分明朗了。而且从根到叶子有且只有只有一条路径，可以通过这条绝对路径来查找文件，而且可以设置当前目录，用相对路径表示到另一个文件的走法，玩过linux的同学肯定知道cd&nbsp;.&nbsp;和cd&nbsp;..等命令吧，用的就是相对路径。当然，这样做有利也有弊端，利在于其在树中的路径是唯一的，可以解决重名问题，而且这个树形结果非常灵活，添加和删除文件或者目录，只需要改变一下树就可以了。比起单级文件要好得多，但是这样查找起来又不是很方便了，必须遍历这棵树，或者根据所给的路径去找文件，当目录层次比较多的时候，树的深度比较深，查找起来就比较耗费时间。但是总的来说，还是这个方法好，比较贴近于我们的思维和计算机的运算方式。</span></p><p><br></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">【如何查找】</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">有了存放目录和文件信息的结构，我们该如何查找需要的文件的信息呢？包括物理地址和文件名等属性。大致有两种方法，一种是线性检索法，一个个找，没什么好说的，就像遍历数组一样。另外一种是hash映射的办法，这种办法是用一个hash表达式计算目录到底放在哪里，这样可能算一下就能找到目录项所在，但是这种方法要避免冲突才是好的。</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px"><br></span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">【文件共享问题】</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">如何找的自由已经解决了，接下来就是让文件自由交换的问题了。因为每个文件都有可能属于不同的主人，而主人有很多东西是不能给别人看或者用的（比如牙刷、再比如一个存了银行密码的文件），因为他们有不同的权限，而有些东西是需要共享的，比如团队在工作站中的代码。共享才是王道，为了共享，就很有必要让我可以轻松地访问你的文件，但是复制一份的成本太高了，所以如果能有个链接连到真正的文件会更划算。</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">方法一：</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">如果是在树形目录中，要加入链接，势必会破坏树的特性（根到叶子有且仅有一条路径），虽然共享文件有多个父目录了，但是这样会带来混乱。在书中加入链接之后，就成为了图，假如一个目录&nbsp;dir&nbsp;要包含&nbsp;anotherDir&nbsp;里面的&nbsp;&nbsp;file.txt文件，那么就要将file.txt&nbsp;作为一个目录项附加到dir下，但是这样这个文件只会出现在做了此操作的目录下，它记录的是一个另一个目录项，而不是直接的文件，而且其他用户不知道你增加了一个文件，所以不能通过第二个人共享这个文件。所以引入索引节点——存储了文件的物理地址信息的结构，它会记录有多少人共享了它，每在一个地方增加或者删除都能反馈到索引节点中。也就是说，这个文件被共享了，第二者都能看到你多了一个文件。但是这样会产生权限不清的问题，有ABC&nbsp;三个用户，A授权B共享文件file.txt，当A不用了，就在A的目录中删除该项，然而它在磁盘中还是存在的，因为B还要用，而B又可能授权C&nbsp;共享，这样文件的归属就很不明确了，是先属于A后属于B，还是一直属于B；而文件的归属决定谁对file.txt&nbsp;具有管理权限，这是很重要的。</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">方法二：</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">符号链接：创建一种文件link（不是编译的那个东西，更像超链接），里面存储着另外一个文件file.exe的绝对地址，然后打开这个文件的时候，运行的却是file.exe.这就是我们经常看到的链接文件——快捷方式。我们的桌面的很多图标等带有小箭头的东西是一个快捷方式，它很小，但是很强大。这样就不用破坏文件的树结构，而只需要添加一条链接可以存储在目录项中，记录这个新的link文件的信息。但目录项中已经没有了直接链接到file.exe的目录项了。link就像我们的超链接一样，可以任意在世界的各个角落穿梭。这就像手持一个GPS,朝着目的地走就是了，不用理会那么多。</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">【文件的保护】</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">在上面的文件共享中说到，文件要有个权限记录，记录谁对它有什么样的权利。在linux中权限会有Read&nbsp;&nbsp;Write&nbsp;Execue，对于每个身份（属于某个域），用它们来描述。</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">如果一个文件在751&nbsp;，它的各个域的权限如下：</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">第一位7：&nbsp;文件创建者，拥有RWE&nbsp;三项权限&nbsp;111</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">第二位2：文件拥有者同组者，拥有R和E权限&nbsp;&nbsp;101</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">第三位1:&nbsp;&nbsp;其他人，拥有E权限&nbsp;001</span></p><p><br></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">这样就有了一个秩序，不会搞不清等级。这样就能产生一个文件访问矩阵，例如下面的表</span></p><p><img src="../admin/ueditor/server/upload/uploadimages/41241335225006.jpg" width="638" height="480" style="float:none;" border="0" hspace="0" vspace="0"><br></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">单独拿出一列来看，我们以文件为单位，记录各个用户对文件的访问权限&nbsp;——访问控制表（控制对文件而言）。</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">单独将一行抽取出来，我们以用户为单位，会有许多项文件的访问权限记录——访问权限表（权限对用户而已）。</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">&nbsp;</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">而还有三种特殊的权力，可以修改这两张表和访问矩阵。</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">复制权&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同一个文件的权限在不同用户之间复制。</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">所有权&nbsp;&nbsp;&nbsp;&nbsp;可以增加或者删除一个文件不同用户的权限。</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">控制权&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;控制用户在一个用户中，修改对各种文件的访问权限，可以标志从一个域访问另一个域，方便了进程对文件的修改。</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">【小结】</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">操作系统的文件系统是相当复杂的，我们也获得了初步的自由，可以按我们的意愿访问文件，查看或者修改文件的权限等等，我们也知道实现的原理。当然这篇也只是惊鸿一瞥，拾人牙慧。真正要理解文件系统，还得亲手去写才能体会，笔者就十分迫切地动手以加深理解。文件系统最核心的部分还是在于文件的目录表，它决定我们查找的方式，也就决定我们查找的效率。另外，推荐一个软件&nbsp;everything，其查找文件相当快，是技术人必备软件，其速度之快，难以想象。当然它肯定是对文件建立目录，然后迅速查找它建立的目录，而系统自带的查找工具则逊色很多，有兴趣可以研究其目录表和查找算法。</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">&nbsp;</span></p><p><span style="font-family:&#39;comic sans ms&#39;;font-size:16px">by&nbsp;bibodeng&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2012-04-24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原载于http://bibodeng.web-149.com/</span></p><p><br></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2012/04/20/从生产线到DNA序列检测——强大的动态规划算法/" itemprop="url">
                  从生产线到DNA序列检测——强大的动态规划算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2012-04-20T15:43:47+08:00" content="2012-04-20">
              2012-04-20
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2012/04/20/从生产线到DNA序列检测——强大的动态规划算法/" class="leancloud_visitors" data-flag-title="从生产线到DNA序列检测——强大的动态规划算法">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
<br>
<style type="text/css">

    .Abstract

    {

        padding: 15px;

        border: dotted 2px #999;

        color: #999;

        font-family: 'Microsoft Yahei';

        border-radius: 4px;

    }

        

    .third_title

    {

        margin: 10px 0;

        font-family: 'Microsoft Yahei';

        text-align: left;

        padding: 6px 20px;

        color: #fff;

        background: #55895B;

        font-size: 20px;

        #border-radius: 4px;

        clear: both;

    }

        

        

    .Second

    {

        margin: 10px 0;

        font-family: 'Microsoft Yahei';

        padding: 6px 20px;

        background: #93C8A2;

        color: #fff;

        font-size: 18px;

        border-radius: 4px;

        clear: both;

    }

        

        

    .Third

    {

        margin: 10px 0;

        padding: 6px 20px;

        font-family: 'Microsoft Yahei';

        margin: 15px 0;

        font-size: 16px;

        color: fff;

        background: #C6EFD2;

        color: #999;

        border-radius: 4px;

        clear: both;

    }

    .note

    {

        margin: 10px 0;

        padding: 15px 20px 15px 60px;

        background: #FCFAA9 url('http://images.cnblogs.com/cnblogs_com/daoluanxiaozi/372646/r_o_yellow-pin.png') no-repeat 20px 0;

        font-size: 15px;

        font-family: 'Microsoft Yahei';

        box-shadow: 0 0 8px #aaa;

        clear: both;

    }

        

    .demo

    {

        text-align: left;

        padding: 6px 20px;

        overflow: auto;

        border-radius: 4px;

        background: orange;

        color: #fff;

        font-size: 16px;

        clear: both;

    }

        

    .cnblogs_Highlighter

    {

        border: solid 1px #ccc;

        clear: both;

    }

</style>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2012/04/17/操作系统之文件管理/" itemprop="url">
                  操作系统之文件管理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2012-04-17T07:23:39+08:00" content="2012-04-17">
              2012-04-17
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2012/04/17/操作系统之文件管理/" class="leancloud_visitors" data-flag-title="操作系统之文件管理">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
<div><span style="font-family:'Microsoft YaHei';font-size:14px;">今天学习了操作系统的文件系统管理，主要是在磁盘上的文件管理。磁盘上的文件有很多种类型，按照大体来分可分为有结构和无结构两种，而有结构是指该文件包含一些数据项，这些数据项组成一条条记录，这些记录再组成一个结构文件。这个东西感觉起来像是数据库里面的表一样的，有属性有元组，我的理解就是，一些系统的东西如数据库以及系统文件需要存成一些字段的形式，而且方便查找。而无结构的就很多了，许多我们常见的文本文件，源文件，可执行文件，长短不一，格式各异。总的来说无结构文件就像它的名字所揭示的，没有特定的结构。用一个不太恰当的比喻，格式化的文件就是很多固体的晶体，其是有一定结构的，而且分下去总是有一定的规律，而无结构的就像水，很随意地组合，形成一个流。</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">&nbsp;</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">文件有许许多多的属性，包括文件类型、文件长度、文件位置、文件的权限、创立时间等等，总之我们平常接触的很多关于文件的属性，我们差不多都已经能叫出名字来。很经典的就是文件的类型，大一学习计算机科学导论，就要我们例举出许多文件类型，什么txt、bin、bat、com、gif、png、mp3、mpeg等等应有尽有，但是任何一个应用程序都可以搞出一种自己的后缀名，这样会记死人的。文件应该可以分为：可执行文件、源文件、数据。而我们每天打交道的就是这些东西，点开一个程序，就是加载了一个可执行文件，打开一个文本就是打开了数据，编代码更是家常便饭，无需多说。</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">&nbsp;</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">像数据结构一样，文件存储在计算机的外存中，也是有位置的，而且按照存放的方式可以分为：顺序存储、非顺序存储。顺序存储有点像我们学习的数组类型，逻辑上和物理上都是连续的，可以随机访问，但是要插入就难了。而非顺序存储则是数据可以分开存放，一个块中记录着该信息的下一个块号，所以就像链表一样可以逻辑上连续，但是物理上可以不连续，这就像链表，这样插入和删除就很方便了，但是查找就需要按照顺序来查找了。当然并不是所有的顺序存储的都可以随机存取，而是只有定长的，可以直接计算出数据地址的才可以，而对于变长的，由于每一个数据项i的地址都是前i--1个数据项长度的和，而每个数据项可能长度不相等，这样就只能挨个计算了，这是十分不划算的。但现实往往就是这样，我们则需要用智慧来发明更好的方法来节省时间，时间就是money呀！于是有表的出现，计算一次地址就行了，然后之后需要的话再查表。或者使用一种算法将数据块散列开来，可以直接计算出地址来。顺序存储的文件适合那些访问速度要求高的，数据变更少的，而这又跟硬盘有关系，待会会讲到硬盘。系统文件一般不允许用户修改，所以变更会比较少，而用户文件则不同了，随时都有可能进行更改。我们经常会清理一下硬盘的碎片，让那些文件尽可能地移动到一块连续的区域，为的是加快系统访问硬盘中文件的速度。</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">&nbsp;</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">就硬盘而言，有若干个盘片，一个盘片有两个盘面，一个盘面配备一个读写磁头，一个磁头往盘片圆心做径向运动，通过读写臂伸缩实现（读写耗时最长的动作），然后是找到对应的扇区，进行读写操作。一个盘片有许许多多的磁道，就是同心的弧，这些弧虽然长度不同，距离圆心越远的，相同角度所对应的弧长越长。而这些磁道虽然长度不同，但是存储的信息都是512字节，之所以这样是因为他们的存储密度不相同，同时盘片磁道的相对于磁头的线速度也不相同。</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">&nbsp;</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><p><span style="font-family:'Microsoft YaHei';font-size:14px;">今天就写到这里，我半知不解这些存储知识，还是需要拿本书好好看看，那些文件系统的算法到底是怎样的，而系统又是怎样通过这些算法管理这么大的存储空间的，真是令人好奇，必要的时候，动手敲敲算法，这样才能全面地掌握这些理论的知识。</span></p>
<p><span style="font-family:'Microsoft YaHei';font-size:14px;"><br>
</span></p>
<p><span style="font-family:'Microsoft YaHei';font-size:14px;">by bibodeng 2012-04-16</span></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2012/04/06/原则与习惯——做个高效能人/" itemprop="url">
                  原则与习惯——做个高效能人
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2012-04-06T22:38:49+08:00" content="2012-04-06">
              2012-04-06
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2012/04/06/原则与习惯——做个高效能人/" class="leancloud_visitors" data-flag-title="原则与习惯——做个高效能人">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
<div><span style="font-family:'Microsoft YaHei';font-size:16px;">今天（4月1日）还算很开心，独自一个人在校园里散心，因为昨天很心烦，今天走出去，才发现，一直以来忙忙碌碌，都没有好好地端详眼前这座校园。校园很静谧，下午只听到归鸟的啁啾，走在铺着落叶的林荫道，还能听见自己的脚步声。什么喧嚣都没有了，远远地看着一些同龄人在球场挥洒汗水。</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">&nbsp;</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">边散步，边问了自己一些问题，这几天想了很多，发现了一些让生活更好的方法。人生的路还有很长要走，我想成为自己梦想中的那个人，所以我需要有自己的原则与愿景。所以我一一写下它们，我发现当这些东西变成原则的时候，我做事情总能够忠于自己，诚实地坚持自己的原则。当然，万事没有绝对，这些原则也在变化当中，随着我们对自我认识的深入，会渐渐调整。</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">&nbsp;</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">我的原则：</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">&nbsp;</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">珍惜时间，刻苦钻研（学习上）</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">&nbsp;</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">坚持锻炼，健康为重</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">&nbsp;</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">对社会有所奉献</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">&nbsp;</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">修养身心，做到勇敢正直、诚实守信</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">&nbsp;</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">尽力帮助周围的人成功</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">&nbsp;</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">关爱他人，关爱自己，关爱家人</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">&nbsp;</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">为人孝悌，言行合一</span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">&nbsp;</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">【发现自我规律】</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">&nbsp;</span></div>
<span style="font-size:16px;"> </span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">这些原则都是非常符合高尚的道德情操的，光有原则是不够的，我的生活还需要习惯来规范，否则一切事情做起来很没有重点，而且浪费时间。最近发现一些生理规律：</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">&nbsp;</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">1、晚上快睡觉的时候和早上刚起床的时候是最清醒的一段时间，适合用来学习困难的课程，或者自学（一个舍友每天早晨花时间自学linux）。</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">&nbsp;</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">晚上睡前：很容易纵观今天干了些什么，适合计划一下明天该做什么，可以完成to do 
list，只写三四条，第二天比较容易完成。记得高二的时候，由于成绩滑落，被老师叫去询问，他叫我晚上睡前回忆一下今天所学内容，坚持一个学期，结果我的成绩很快回到原来的水平。</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">&nbsp;</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">早上起床：适合总结归纳一下昨天所得，决定今天应该怎么做。写下一些体悟出来的东西，尤其是捕捉灵感，学习比较难的知识（如算法、数学）</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">&nbsp;</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">大二的课程都相当重要，原来想读的那些经典一本都看不完（主要是看不进去，其实耐心是可以看进去的），所以进步非常地缓慢。现在书单里面增添的都是一些杂七杂八的实用或者社会科学的作品。而自己以前文科都还算可以，近来又迷上了绘画与书法。要做的事情真的很多，但是时间那么有限，所以一定要保证在有一个长一点的时间片内集中精力。攻克专业课上的难题（如去图书馆两小时看《算法导论》）。</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">&nbsp;</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">学习算法，每天利用早上的十多分钟来学习，而晚上则看看其他书籍，拓展一下视野，帮助全面发展，刺激大脑交替使用。梦想，激情，坚持，习惯 
是重要的品质，也是将来变得优秀的保证。</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">&nbsp;</span></div>
<span style="font-size:16px;"> </span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">【自我管理-时间安排】</span></div>
<span style="font-size:16px;"> </span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">&nbsp;</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">自从有了微博之后，花在微博上的时间非常巨量，减少微博和空间的时间，我的寄托不是在别人的身上，而是在现实中，或许在图书馆里，或许在计算机里，抑或者在我本身。不能花太多时间去关注我关注的东西，而更应该化被动为主动去制造自己的影响范围，用言行一点点扩大影响力。但是我还是会关注我的那些朋友们，因为他们对我来说很珍贵，因为对他人的好，也是一种积极向上的扩大影响力的行为。当然扩大影响力的目的不是单纯地为了扩大影响力本身，而是基于高尚品格的面向理想地扩大，是对自己和他人都有帮助的行为。</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">&nbsp;</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">&nbsp;</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">保证作息上需要有规律一点，这样对于保证身体健康有益，所以今后11：30分上床睡觉，然后早上早点起床，充分利用大脑清醒的时间，做更多有意义的事情。当然生活也不能少了情趣，没事去散散步，运动运动，总之就是不能让自己太懒散，也不能让自己吃不消。这几天准时睡觉了，果真能够按时起床，符合自然规律地作息，整个人都变得有精神了。</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">&nbsp;</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">中午的时候时候保证一个小时的睡眠，否则中午不睡，下午崩溃。睡一个钟醒来的感觉，只能用一个字来形容——爽。这时候满面红光，手掌微热，为下午的课奠定基础。</span></div>
<span style="font-size:16px;"> </span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">&nbsp;</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">【永恒的学习】</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">&nbsp;</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">常常去图书馆，上个学期期末的时候，我在平时画图的本子背后，留了两页来记录我去图书馆的信息，本来要求自己期末一个月要去够20次，结果自己做到了，一算去的时间超过了50小时，这是一笔很大的时间财富。记录的时候，把次数、学习内容、时间长短、感觉都记下来了，慢慢地就成了习惯，很容易地就记录自己去图书馆的信息。</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">&nbsp;</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">晚上睡觉的时候听听慢速英语，提高英语听力水平，这是师兄给的建议，虽然师兄没有过六级，但是我重蹈了师兄的覆辙，所以还是形成一个这样的习惯比较好，听了一阵子，有时候还真的能捕捉到几个单词（special 
voa : 
P),俗话说，要利用一切可以利用的时间，高效地学习。最终这个英语还能起到分散思考注意力，达到快速入睡的功效。但是记住一定不要带着通过六级的心态去听，那是自我安慰，不该想太多我为什么这么做，而应该多想想我能做什么变得更强。同时也可以用有声电子书来阅读一些书籍，这样可以在无形当作积累相当大的阅读量。同宿舍一个同学，洗衣服的时候听唐骏的《我的成功可以复制》，虽然我常常笑“喔！又在听唐骏的故事”，但是他还是很认真地把整本书听完了，而且还写了详细的读后感，另外十分敬佩，当然最好选些轻松无压力，又能有所收获的书籍来听。</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">&nbsp;</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">【锻炼】</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">&nbsp;</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">锻炼的习惯，宿舍的同学纷纷在宿舍搞运动，而对于想要增强体质的我，每周只能抽出周三或者周六的下午去运动，平时只是每天做几个深呼吸。</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">&nbsp;</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">&nbsp;</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">克服焦虑，只好好地把握住今天，每天的时间分配在各项工作，每天进步一点点，积累下来就很了不起了。不仅仅做一个有良好习惯的人，更是一个高效能人。这些习惯都是慢慢发觉的，因为这样做的时候效率往往最高，当然这只是个人的情况，应该按照每个人的情况来制订，以达到最佳效果。</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">&nbsp;</span></div>
<span style="font-size:16px;"> </span><span style="font-family:'Microsoft YaHei';font-size:16px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:16px;">by bibodeng&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2012-04-06</span></div>
</div>
</div>
</div>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2012/04/01/清明小记/" itemprop="url">
                  清明小记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2012-04-01T20:44:21+08:00" content="2012-04-01">
              2012-04-01
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2012/04/01/清明小记/" class="leancloud_visitors" data-flag-title="清明小记">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
<div><span style="font-family:'Microsoft YaHei';font-size:14px;">从小懂事起就住在我的外公家，所以清明节日等等也跟随着外祖父一起去祭拜祖先。回想起来，当年是多么具有清新放松的气息，一路上踏着歌声，走览鲜花去祭拜祖先的居所——青山。这一天，常常是天气很好的，外祖父就领着我，去曾外祖父和曾外祖母的墓地去割除杂草，摆上祭品，烧一些纸钱。虽然是墓地，但是却有一种亲切感，丝毫不会害怕。</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">&nbsp;</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">扫墓的过程大都是千篇一律的，就是用镰刀或者锄头将长在地圹旁的树，草出去，还要弄好墓地的石头砖块。但是中国人追思先人，感佩先人，教育子女的好传统从扫墓中传承下来了。边扫墓，外祖父便会跟我们将，外祖父是一个什么样的人，平时对待子女都是很仁慈可亲。对于一些意义比较不一般的人，外祖父都会细细说当年伯父、父母是怎样疼爱自己的，在感佩着他们的恩德，同时也不忘说几句“您的外孙狗都来看你了”。有几次都是亲力亲为，挑着一些水泥、一桶水去将破败的墓地修缮一下，于劳动中，去体会当一个有孝心的人是怎样的值得尊敬。所以，我对我的父母和祖父母都会觉得他们非常伟大，平时都是不敢违逆。孔子曰过，孝则无违。父母祖父母养育之恩，是一个人一生应当铭记的，同时对于那些逝去的祖先，祈求他们保佑子孙后代为人正直，行好运，得好报。</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">&nbsp;</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">人的始与终都是相当的神圣的，一个新的生命的诞生，往往给人间带来喜悦，而一个生命的逝去，也会给世界带来淡淡的哀伤，从而让人向扇，因为这样才能善事善终。无论我们活着的时候浪费了多少青春似水年华，无论我们做了多少错事，到生命的终结，身体也会灰飞烟灭。但是人的灵魂还活着，活在活人的心里，每当特殊的节日（清明），我们便会追思起我们的先人，同时劝诫自己要见贤思齐，要对得起逝去的祖先，让祖先们觉得，有这样一个后裔（你小子还不错）而感到骄傲。当然慎终追远，人的这份情怀一直延续下去。</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">&nbsp;</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">依稀记得清明寒食的一些诗句，当然最清楚的就是杜牧的“清明时节雨纷纷，路上行人欲断魂”，还有各种寒食节的典故，纪念的是一个介子推的人。当然这些都是历史了，现代的人，骨灰都放在盒子里，最多去公墓里扫扫墓，没有了当年踏青祭祖的味道。不过，人们春天还是喜欢去旅游去踏青，但是却少了祭祀祖先这个环节，我们的父母，不仅仅要提供子女物质条件，也要告诉子女们自己身上的血从那里来，我们的历史。而追思到了一个节点，便是一种新生，传承着中华民族特有的精神——慎终追远。</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">&nbsp;</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">我曾翻阅过外祖父家里的“江夏堂”黄氏族谱，观瞻一些值得追思仰慕的先人，同时也了解家族的历史。我们客家人，自中原迁居广东，成为了客家人，实则是汉族。族谱中记录了相当多的人物传记，以及一些历史人物，尘封在岁月里，只等我去翻阅。读至小黄香的故事，顿感己身应当学其孝，然自己实在是做的完全不够。社会中的人，道德越厚，则这个人越受尊重，也更加有可能获得认可。而其内心的宁静，亦有助于获得成功。故而，道德是我们需要从前人中学习的，也是我们生活获得快乐的基石。</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">&nbsp;</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">谨以此文纪念我逝去的祖父母，以及没有见过的祖先，同时也望更多人从踏青游览祭祀中感佩自己的祖先，从而获得更多的量。</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">&nbsp;</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">&nbsp;</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">by bibodeng 2012-04-01</span></div>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2012/03/29/算法的魅力/" itemprop="url">
                  算法的魅力
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2012-03-29T11:58:45+08:00" content="2012-03-29">
              2012-03-29
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2012/03/29/算法的魅力/" class="leancloud_visitors" data-flag-title="算法的魅力">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
<div><span style="font-family:'Microsoft YaHei';font-size:14px;">正儿八经开始学算法了，没有学习算法之前，总觉得编程就是敲代码，知道怎样使用语言就行了，学习了算法之后，才知道这玩意大有用处，而且和数学有非常紧密的联系。虽然我数学不太好，但是我对数学有一种天生的好感，因为它们总是给人带来一种惊艳感。或许是小时候并不害怕数学的缘故吧，于是勉强坚持一下，老师所讲的那些动态规划、贪心算法居然能听懂了。但是看起《TAOCP》却是真正地无所适从，随时都有一种想要扔下书去干别的的感觉，而碰到容易的时候、自己能够理解就会非常地开心。</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">&nbsp;</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">算法这种东西，的的确确需要很大的数学功底。我数学功底不好，该怎么拌？我就一行行照着敲代码，敲到我理解整个过程为止。或者对于我的“成果”（敲出来的代码）一行行进行调试，调试一遍就理解程序的基本原理了，但是自己还是写不出来。当然碰到各种递归，分治，调试的时候就超级没有耐心了，跳跃太频繁，人脑是难以接受的。比如一个quick 
sort 
，先来一个partition，然后就递归解决前半部分和后半部分。真的是神奇，同样是排序算法，有的算法（快排）天生就比另外一些算法（冒泡、插入）更快，当然并不能一概而论，各种算法都有自己的局限以及长处。就像数据结构里面一样，顺序表和链式表都有各自的优点，但是也有各自的缺点，只有因时而异，因地制宜才能发挥它们最大的功效。算法也是一样，insert 
sort在样本少的时候是非常方便的，代码也少，适合那些顺序差不多和目的顺序相同的样本空间。而上述情况对于快排来说就是厄运的到来了，因为它们的思想完全不同，有序情况对快排来说是最糟糕的了，因为要partition打乱了，跳跃性太强，需要再继续排。</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">&nbsp;</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">关于排序算法，记得还收藏过了一个排序的全集歌舞，用舞蹈的形式来展示排序的原理，比较容易懂。链接在</span><a href="http://weibo.com/fav?leftnav=1&amp;wvr=4&amp;key=%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener"><span style="font-family:'Microsoft YaHei';font-size:14px;">这里</span></a><span style="font-family:'Microsoft YaHei';font-size:14px;">。很多书上说计算机的世界里面很多需要排序的东西，而排序算法，便成了我们这堆初出茅庐的rookie们的必经之路。一大堆的排序算法，估计是各IT公司面试时最常考的东西，以前看的《疯狂的程序员》绝影最常被考的就是冒泡排序。而今天，对自己的要求当然不仅仅是能写几个排序，而更是要学会设计算法的本领，提高我们的产能，到时候产出自然就大了。前几天，搭车去本部参加ACM的初赛，居然很简单的问题想不出来，怪的就是没有算法的素养，对于题目的分析，解构，以及建模的能力不够，用惯了蛮力破解，却吃尽苦头编出一个超出时间要求的算法，好的算法往往需要一些基本功：递归、动态规划等的时候，就不知道从何处下手。结果可想而知——铩羽而归。当然，这也只是现阶段的情况而已，随着算法课程的推进，我们还是能够比较系统地接触各种算法，从而养成良好的算法素养，到时候就更轻松了。</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">&nbsp;</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">今天读到一篇hack 
news说一个音乐生，跟着一个老师学才两年就大学毕业了，一个人真的可以学得很快，质的飞跃也往往只是需要半年的时间而已。而如果遇到了适合自己胃口的老师讲课，那么效率便会大大提高。我们于平常的学习中浪费了太多的时间，时间的确像海绵，但是挤出来的都浪费在别处去了。所以更难能可贵的是合理地管理自己，把重要知识掌握了，或者开辟一个大的时间内存，用于高效地运行一个“作业”。计算机能够分时、能够多进程、多线程，虽然从宏观上来讲，我们也是可以多进程的，但是就一个较短的时间段来说，我们还是应当高效地利用时间来学习重要的课程——数据结构和算法。也许读完了《算法导论》就可以很快上道了，要是能硬着头皮把《TAOCP》读完了，也就算得上是学有所成了。对于算法学习，很有必要给自己一个时间范围，给自己一个原则：“真的弄懂学习的算法，并在恰当的时候能够用上”。而且，越来越感觉到代码给人的直观性，敲过之后印象会更深刻。什么听懂了，看懂了，都是屁话，只有拉出来能够自己随手写一个才是真正的懂了。</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">&nbsp;</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">以一个很惊奇的结果做结尾，做为启示：世界上的事物并非无缘无故的，而是有着千丝万缕的联系，而这种联系又是如此的精妙。就在你认为是毫无联系的情况下，有人发现了奇妙的联系。</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">&nbsp;</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">project euler 052：找出一个数x，这个数的1、2、3、4、5、6倍都是由相同的一些数字组成，而且位数相同，求出这个数x。 </span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">&nbsp;</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">咋一看，就是用Bruce 
方法来破解，去试一试这些所有可能的结果。我苦逼了半天，辛辛苦苦地写出十几二十行代码，求得了正确的结果，可是看到反馈的第一条就是，这个人压根没有用计算机，就算得了结果，我十分地惊讶。</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">&nbsp;</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">这个人说 1/7 = 0.142857... 而2*142857 = 285714； 3*142857 = 428571 ；4*142857 
=571428 ；5*142857=&nbsp; 714285；6*142857=857142 真的是非常神奇！！ 而7*142857 =999999 </span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">&nbsp;</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">你现在你敢说这些数位和6是没关系的了吗？毕竟6和7有很大关系。而这之间的关系到底有多么深层呢，本质又是什么呢？这估计要去问群论的数学家了吧！</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">&nbsp;</span></div>
<span style="font-family:'Microsoft YaHei';font-size:14px;"> </span><div><span style="font-family:'Microsoft YaHei';font-size:14px;">从中我悟到一个道理，那就是，算法要充分利用事物之间的联系：联系说不定就隐藏在表象的深层，充分利用联系的算法才是好的算法。</span></div>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2012/03/14/初学算法/" itemprop="url">
                  初学算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2012-03-14T21:23:18+08:00" content="2012-03-14">
              2012-03-14
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2012/03/14/初学算法/" class="leancloud_visitors" data-flag-title="初学算法">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
<div><span style="font-size:14px;font-family:'Microsoft YaHei';">这个学期才刚刚接触算法，之前对于算法总是觉得高高在上，可望不可及。现实真的是这样，算法真的很难学哪，所以自认很菜鸟的我从来都很少写技术性的文章，实在是有点过意不去。不过这个学期的老师真的是非常好，能够和我们打成一片，让我对算法兴趣大增，感觉掌握了这门技术就十分的了不起。</span></div>
<span style="font-size:14px;font-family:'Microsoft YaHei';"> </span><span style="font-size:14px;font-family:'Microsoft YaHei';"> </span><div><span style="font-size:14px;font-family:'Microsoft YaHei';">&nbsp;</span></div>
<span style="font-size:14px;font-family:'Microsoft YaHei';"> </span><span style="font-size:14px;font-family:'Microsoft YaHei';"> </span><div><span style="font-size:14px;font-family:'Microsoft YaHei';">从大一就开始看很多文章，包括李开复的《算法很重要》等等，于是在我的心目中就有了一个信念：算法很重要，我要学好算法。但是一直以来都在忙着其它“技术”，譬如学习编程语言，玩玩单片机啦，总之很“花心”。真正的基础技术——数据结构和算法却没有怎么注重。大二上才学的数据结构，也算认真听了，也挺有收获的，但是一到大二下的算法课我就懵了。特别是刚接触分治和递归，在动态规划这里纠缠，借了一本《算法之道》来看，写得非常好，但是我要很久才能进入状态从而理解其中的原理。我甚至怀疑是否是自己太笨3。</span></div>
<span style="font-size:14px;font-family:'Microsoft YaHei';"> </span><span style="font-size:14px;font-family:'Microsoft YaHei';"> </span><div><span style="font-size:14px;font-family:'Microsoft YaHei';">&nbsp;</span></div>
<span style="font-size:14px;font-family:'Microsoft YaHei';"> </span><span style="font-size:14px;font-family:'Microsoft YaHei';"> </span><div><span style="font-size:14px;font-family:'Microsoft YaHei';">初初接触算法，就有一种特别强烈的想要实现它的感觉。看的时候总是会忽略大大小小的细节，然后在写的时候，到处出错。所以说，看懂了、读懂了都是屁话，只有实现了一遍而且有深刻领悟了才能说会了。许许多多的牛人都曾经说自己青涩的时候是怎么学习编程的——都是敲代码敲出来的，就算是抄也能锻炼手感。这几周只学了一章 
分治和递归，就已经有许许多多的名堂了，什么归并排序、斐波那契、阿克曼函数等等全部出来了，这些初级问题当然是基本功，但是接下来的东西就比较有意思了：动态规划，这个东西用我自己的话来描述就是将复杂的问题分解成多个递归子问题解决的，这些小问题可以有重复，然后就需要我们找到一种方案（从底向上），使得怎样安排会最优，而这里的关系也是一步步的影响的（不知道理解的对不对，好模糊）——随机应变。好啰嗦呀，一步步的判断到底要走哪条路，当然要进行精细的计算了。虽然对它的理解非常地模糊，却使我想起来了project 
euler里面的一道题目，就是在一个三角形数堆找从上到下的和最小的路径，很显然就是利用动态规划的方法，当时是每一层的和进行比对，找最小的，如此直到最后（很显然是从底向上的构建过程）。</span></div>
<span style="font-size:14px;font-family:'Microsoft YaHei';"> </span><span style="font-size:14px;font-family:'Microsoft YaHei';"> </span><div><span style="font-size:14px;font-family:'Microsoft YaHei';">&nbsp;</span></div>
<span style="font-size:14px;font-family:'Microsoft YaHei';"> </span><span style="font-size:14px;font-family:'Microsoft YaHei';"> </span><div><span style="font-size:14px;font-family:'Microsoft YaHei';">今天做的一个非常有趣的矩阵的连乘就是利用动态规划，因为矩阵的乘法可以结合但是不能交换，而且不同的结合计算次数会不一样。比如一个 2*3 
矩阵A、一个3*2矩阵B 还有一个 2*4的矩阵C，也许班里还有少数童鞋还不知道怎样计算乘法次数（一开始我也不知道），举最简单的例子 A*B&nbsp; 那么得到的是一个 
2*2的矩阵，而根据矩阵乘法的定义，可知要算出一个位置上的数都要计算3次乘法，故而计算乘法的次数就是 2*2*3，其实就是 
行等于列那个数只乘一次即2*3*2。这样计算一下（AB）C 的计算次数，首先计算AB,前面已经得到结果了 
2*3*2，得到一个2*2新矩阵，再和2*4矩阵相乘，要计算2*2*4。故而总共要计算 2*3*2+2*2*4 = 28次。然后计算一下 
A(BC)，先算BC,得到3*4新矩阵，再算 A [新矩阵]，同理得到乘法次数3*2*4 +&nbsp; 2*3*4 = 48 
，两种方式相差了好多呀，真的是不可思议。故而要找到最佳的方法来结合，老师教会我们怎样使用方格来计算，每次这个东西都能解决动态规划的问题，真的是神奇，今天没有讲编程实现，不过一定会有一些if 
else之类的语句。</span></div>
<span style="font-size:14px;font-family:'Microsoft YaHei';"> </span><span style="font-size:14px;font-family:'Microsoft YaHei';"> </span><div><span style="font-size:14px;font-family:'Microsoft YaHei';">我是那张简单的会一点，复杂的我不会的人，但是为了牛逼的梦想，也只能老老实实地学习算法。</span></div>
<span style="font-size:14px;font-family:'Microsoft YaHei';"> </span><span style="font-size:14px;font-family:'Microsoft YaHei';"> </span><div><span style="font-size:14px;font-family:'Microsoft YaHei';">&nbsp;</span></div>
<span style="font-size:14px;font-family:'Microsoft YaHei';"> </span><span style="font-size:14px;font-family:'Microsoft YaHei';"> </span><div><span style="font-size:14px;font-family:'Microsoft YaHei';">学算法是必须经得起考验的，算法是一种技术，一开始可能需要记忆，当这些深层次的思想进入我们的编程习惯中后，那么编起来将会得心应手。多跟老师学，学会一些经典的算法，了解它的来龙去脉，能够理解整个思路，找一本《算法导论》或者是TAOCP(假如能够啃的下的话)，慢慢地学习这门技巧。</span></div>
<span style="font-size:14px;font-family:'Microsoft YaHei';"> </span><span style="font-size:14px;font-family:'Microsoft YaHei';"> </span><div><span style="font-size:14px;font-family:'Microsoft YaHei';">&nbsp;</span></div>
<span style="font-size:14px;font-family:'Microsoft YaHei';"> </span><span style="font-size:14px;font-family:'Microsoft YaHei';"> </span><div><span style="font-size:14px;font-family:'Microsoft YaHei';">by bibodeng&nbsp; 2012-03-14</span></div>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/16/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/18/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/bitcoin-cash-logo.svg"
               alt="bibodeng" />
          <p class="site-author-name" itemprop="name">bibodeng</p>
          <p class="site-description motion-element" itemprop="description">区块链爱好者，互联网从业者</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">189</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/bibodeng" target="_blank" title="Github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/bibodeng" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/bibodeng" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://ifwallet.com" title="IFWallet" target="_blank">IFWallet</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://ifpass.cash" title="IFPassword" target="_blank">IFPassword</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bibodeng</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("RrMSWOa8nuCnCCWn8TyPa7Od-gzGzoHsz", "8xnzit83sqv6vUEuXlsEWe0s");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
