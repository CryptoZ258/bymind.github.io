<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="计算机 比特币 互联网金融 IFWallet" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="区块链爱好者，互联网从业者">
<meta name="keywords" content="bibodeng, blockchain, bitcoin, bitcoin cash, life, programmer">
<meta property="og:type" content="website">
<meta property="og:title" content="bibodeng">
<meta property="og:url" content="https://bibodeng.github.io/page/7/index.html">
<meta property="og:site_name" content="bibodeng">
<meta property="og:description" content="区块链爱好者，互联网从业者">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="bibodeng">
<meta name="twitter:description" content="区块链爱好者，互联网从业者">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> bibodeng </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">bibodeng</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Think By My Mind</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/11/09/latex生成各种格式电子书/" itemprop="url">
                  latex生成各种格式电子书
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-11-09T23:36:29+08:00" content="2013-11-09">
              2013-11-09
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2013/11/09/latex生成各种格式电子书/" class="leancloud_visitors" data-flag-title="latex生成各种格式电子书">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="使用latex源码生成各种格式电子书"><a href="#使用latex源码生成各种格式电子书" class="headerlink" title="使用latex源码生成各种格式电子书"></a>使用latex源码生成各种格式电子书</h1><p>by bibodeng 2013-11-09</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了让电子书能够在更多的平台上被阅读，那么则需要生成各种版本的电子书，这个过程真的有点蛋疼，但是通过各种非常有用的工具，干起来也非常快。下面主页记录一下常用的格式的生成：</p>
<pre><code>PDF，mobi， epub， html
</code></pre><p>其中PDF是最容易的，latex编译默认就输出PDF，所以我们很容易获得。而且上篇已经提及了如何生成6吋版的PDF电子书。所以下面着重讲一下其它三种格式的生成。</p>
<h2 id="epub"><a href="#epub" class="headerlink" title="epub"></a>epub</h2><p>epub格式是一种在苹果手机，平板上使用的通用格式，目前kindle还不支持，但是有些kindle的系统——如多看，已经支持epub格式的电子书了。在ubuntu下，可以使用pandoc这个工具，从latex文件直接生成epub格式电子书。</p>
<p>首先，我们要安装pandoc：</p>
<pre><code>sudo apt-get install pandoc
</code></pre><p>这样就安装好了。它的详细使用方法见<a href="http://johnmacfarlane.net/pandoc/epub.html" target="_blank" rel="noopener">这里</a>。我们直接使用pandoc命令转换格式：</p>
<pre><code>pandoc book.tex -o book.epub
</code></pre><p>可以看到立马生成了一个book.epub文件，将该书籍导入到calibre里面查看，可以看到转换的格式还行,稍微有一点瑕疵，大体上还是ok的。</p>
<p><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201311/279d39080390d5733af232089be3a0082013110907505713841.png" alt="epub版"></p>
<h2 id="mobi"><a href="#mobi" class="headerlink" title="mobi"></a>mobi</h2><p>mobi格式可以使用calibre直接从epub格式进行转换，安装完该软件后，直接对文件进行转换。等待一段时间，等其转换完成，打开发现mobi格式和epub几乎一样。</p>
<h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><h3 id="tex2page"><a href="#tex2page" class="headerlink" title="tex2page"></a>tex2page</h3><p>要生成html有许多工具，但是我们先介绍一种——tex2page，这里有一份王垠写的<a href="http://docs.huihoo.com/homepage/shredderyin/tex2page/intro.html" target="_blank" rel="noopener">教程</a>。</p>
<pre><code>tex2page book.tex
</code></pre><p>一般是可以编译成功的。如果在文档目录下新建一个和tex文档同名的.hdir文件，里面添加一行</p>
<pre><code>pages
</code></pre><p>则会在生成网页的同时能够把文件都放在pages下面，而不会在当前目录搞乱你的文档。</p>
<h3 id="tex4ht"><a href="#tex4ht" class="headerlink" title="tex4ht"></a>tex4ht</h3><p>还有一种办法是安装一个tex4ht，然后使用htlatex命令来转换。</p>
<pre><code>sudo apt-get install tex4ht
htlatex mydocument.tex 
</code></pre><p>这样会生成一个html文件。</p>
<h3 id="pandoc"><a href="#pandoc" class="headerlink" title="pandoc"></a>pandoc</h3><p>pandoc真的是一个神器啊，可以转换各种格式，这里有个<a href="http://johnmacfarlane.net/pandoc/demos.html" target="_blank" rel="noopener">示例</a>。</p>
<pre><code>pandoc -s -S --toc -c book.css book.tex  -o book.html
</code></pre><p>可以使用自定义的样式为生成的html进行排版。这样的效果会好一点：</p>
<p><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201311/61661a8b55f13cc8bf9de521300735352013110915351330487.png" alt="IT小小鸟网页版"></p>
<hr>
<p>end</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/11/09/xelatex在文档处理中的使用/" itemprop="url">
                  xelatex在文档处理中的使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-11-09T13:18:02+08:00" content="2013-11-09">
              2013-11-09
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2013/11/09/xelatex在文档处理中的使用/" class="leancloud_visitors" data-flag-title="xelatex在文档处理中的使用">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="xelatex在文档处理中的使用"><a href="#xelatex在文档处理中的使用" class="headerlink" title="xelatex在文档处理中的使用"></a>xelatex在文档处理中的使用</h1><p>by bibodeng 2013-11-09</p>
<h2 id="latex和pdflatex的问题"><a href="#latex和pdflatex的问题" class="headerlink" title="latex和pdflatex的问题"></a>latex和pdflatex的问题</h2><p>使用latex来直接编译，在有<code>\tableofcontent</code>的情况下会出现一些怪异的<code>unicode char \u8之</code>这样的错误，使得目录不完整。其原因是使用的<code>CJKutf8</code>的宏包所包含的utf8字符是不完整的，故而有些中文字符支持不完整。但是诡异的是同一个字符，在某些地方是ok的，在另外一些地方就是不行，可能是第一次编译输出的时候出错。如下的代码为<code>latex</code>文档：</p>
<pre><code>\documentclass[12pt,oneside]{book}
\usepackage{CJKutf8}
\usepackage[utf8]{inputenc}
\usepackage[titletoc]{appendix}
\usepackage{indentfirst}  % first paragraph indent
\setlength{\parindent}{2em}
\pagestyle{plain} % set the footer simple ,only a page number headings

\begin{document}

\begin{CJK*}{UTF8}{gkai} % gkai gbsn

\protect\setcounter{tocdepth}{1}
\tableofcontents  % 目录，二次编译

\section{中国} % 含有中文字符，在生成tableofcontent的时候可能出错
\begin{verbatim}
我爱你中国   
\end{verbatim}

\end{CJK*}
\end{document}
</code></pre><p>将会产生如下的错误：</p>
<p><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201311/ba66d70c572c38dc44f202b3b8752f812013110904382232028.png" alt="unicode没设置报错"></p>
<p>尝试过在<code>\end{CJK*}</code>之前以及文档结尾加<code>\newpage</code>,都没有效果，在<code>stack exchange</code>也没有找到合适的答案。后来发现<code>texlive</code>可以解决这个问题。而需要安装<code>texlive</code>工具包，然后使用这个新的发行版的引擎来编译文档，所以文档需要重写了。</p>
<h2 id="安装和使用texlive"><a href="#安装和使用texlive" class="headerlink" title="安装和使用texlive"></a>安装和使用texlive</h2><p>要安装texlive，必须要有安装的介质，所以需要下载文件等，然后予以安装，这里有一个教程可供<a href="http://seisman.info/texlive-2013-under-linux.html" target="_blank" rel="noopener">参考</a>。中文支持可以暂时不理，到后面我们会使用<code>ubuntu</code>系统自带的中文字体做编译。</p>
<p>安装好之后，就让我们看看其文档结构：</p>
<pre><code>\documentclass[12pt,a4paper]{article}
\usepackage{fontspec,xunicode,xltxtra}
\usepackage{titlesec}
\usepackage[top=1in,bottom=1in,left=1.25in,right=1.25in]{geometry}

\titleformat{\section}{\Large\hei}{\thesection}{1em}{}

\XeTeXlinebreaklocale &quot;zh&quot;
\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt

\newfontfamily\hei{WenQuanYi Micro Hei}  % 使用系统的中文字体
\setmainfont{AR PL UKai CN}              % 这3行定义文档字体，本行正文
\setmonofont{WenQuanYi Micro Hei}        % 标题等

\begin{document}

\title{\hei XeTeX使用小结}
\author{\hei 小明}
\date{\hei 2009年6月21日}

\maketitle

\section{简介}
以前使用CJK进行中文的排版，需要自己生成字体库，近日，出现了XeTeX，可以比较好的解决中文字体问题，不需要额外生成LaTeX字体库，直接使用计算机系统里的字体。

\section{字体列表}
本文使用了大量本机自带的字体。

\centering
你好！

\end{document}
</code></pre><p>可以看到我们的文档中使用了自己系统中的字体，而不是使用各种各样的字体宏包。我们可以使用命令：</p>
<pre><code>fc-list :lang=zh-cn
</code></pre><p>来查看系统中都有什么中文字体：<br><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201311/4901815145f36d1d475207eef5bb44b52013110904593212245.png" alt="fc-list命令结果"></p>
<p>我们要使用的是字体的名字，例如<code>WenQuanYi Micro Hei</code>和<code>AR PL UKai CN</code>,也就是两个冒号之间的那个名字。这样我们果然可以编译出漂亮的使用系统字体的文档了。再把之前latex的文档中的<code>preamble</code>（声明usepackage的地方）部分中的代码拷贝过来放到对应的<code>\begin{document}</code>之前就可以了。然后我们就可以运行 <code>xelatex article.tex</code>来编译文档了，编译后可以看到生成的pdf文件，不会再出现之前的目录错误了。</p>
<pre><code>% preamble示意
\documentclass{class}
… preamble部分
\begin{document}
… 正文内容 …
\end{document}
</code></pre><p>目录正确显示效果:</p>
<p><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201311/e711308f47cbe55a01abd951d4aa3e682013110905133112413.png" alt="目录ok了"></p>
<h2 id="使用latex生成各种尺寸的pdf"><a href="#使用latex生成各种尺寸的pdf" class="headerlink" title="使用latex生成各种尺寸的pdf"></a>使用latex生成各种尺寸的pdf</h2><p>假如我们要生成适合<code>kindle</code>阅读的PDF 6吋版，那么在latex中将非常地方便。因为只需要在<code>preamble</code>中加入如下代码就ok了：</p>
<pre><code>\usepackage[paperwidth=9cm, paperheight=12cm, top=0.1cm, bottom=0.2cm, left=0.2cm, right=0.2cm]{geometry}
\special{papersize=9cm,12cm}
</code></pre><p>而且这个尺寸可以随意更改。所以可以针对特定的屏幕大小进行编译。我编译的6吋版本效果如下：</p>
<p><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201311/26bbead36d401f3407f6de55cac89ad42013110905101210145.png" alt="pdf六吋版本效果"> </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>折腾那么久<code>tex</code>,现在才发现一个好的发行版有多么重要，这样让我们做的工作的轻松起来，而不是捉襟见肘地去解决那些对中文的支持问题。而我们也将使用这个工具，继续我们《IT小小鸟外传》的编写，竭尽全力地制作出良好阅读体验的电子书，并且生成各种版本以支持更多的设备。</p>
<hr>
<p>end</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/11/03/常用latex代码块/" itemprop="url">
                  常用latex代码块
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-11-03T16:27:17+08:00" content="2013-11-03">
              2013-11-03
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2013/11/03/常用latex代码块/" class="leancloud_visitors" data-flag-title="常用latex代码块">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#常用latex代码块</p>
<p>by bibodeng 2013-11-3</p>
<h2 id="为啥搞latex"><a href="#为啥搞latex" class="headerlink" title="为啥搞latex"></a>为啥搞latex</h2><p>其实接触<code>latex</code>也有些日子了，本来是一直打算用它来排版我们自己的简历，论文，还有我们业余写的电子书。最近和思愿在折腾这个东西，故而觉得有必要整理出一篇常用的latex代码块出来，然后结合我们的需要发挥。</p>
<p>宿舍一个哥们总是说我折腾，linux，latex，Qt，折腾的东西真的不少。我自己也问我自己是不是浪费了太多时间在这些不必要的折腾上，后来意识到任何东西都有好处也有不好，就看我们用的人的心态，用的方式了。latex如果用得好，将来写毕业论文的时候必定是让老师眼前一亮，不排除这有点装逼嫌疑，但是我是喜欢酷的，喜欢与众不同。即使是排版，我也觉得用代码什么排出来的会非常漂亮。</p>
<h2 id="常用代码"><a href="#常用代码" class="headerlink" title="常用代码"></a>常用代码</h2><p>有了下面的一些常用代码，我们很容易就解决排版中的一些基本问题，除此之外，建议阅读《一份不太简短的latex说明》。<a href="http://wenku.baidu.com/view/754ab741a8956bec0975e3b2.html" target="_blank" rel="noopener">百度</a>和<a href="http://ishare.iask.sina.com.cn/download/explain.php?fileid=18921996" target="_blank" rel="noopener">新浪</a>提供下载。</p>
<h3 id="嵌入代码块"><a href="#嵌入代码块" class="headerlink" title="嵌入代码块"></a>嵌入代码块</h3><p>如果文档或书籍中带有代码，那么我们常常要使得代码缩进，并且着色。</p>
<pre><code>%　先在文档声明区加入必需的包
\documentclass[11pt,oneside]{book}
\usepackage{CJKutf8}
\usepackage[utf8]{inputenc}
... % 下面这些是重点
\usepackage{listings}
\usepackage{xcolor}
\lstset{basicstyle=\ttfamily,
  showstringspaces=false,
  commentstyle=\color{red},
  keywordstyle=\color{blue}
}
</code></pre><p>然后我们就可以直接在一个章节里面插入代码了，以C++为例，也可以使用Java等其它语言：</p>
<pre><code>\begin{lstlisting}[language=C++,caption={C++ version}]
void main()
{
    printf(&quot;hello world&quot;);
}
\end{lstlisting}
</code></pre><p>上面这段代码向文中嵌入代码。可以看到关键字被染色了，如果有注释的话，还会被染成红色。</p>
<p><img src="http://bibodeng.com/content/plugins/kl_album/upload/201311/96a79f2b7967bfd2a1b6e7766520f9972013110307335829475.png" alt="代码示例"></p>
<h3 id="嵌入图片"><a href="#嵌入图片" class="headerlink" title="嵌入图片"></a>嵌入图片</h3><p>我们的文档常常有一些图片要嵌入，以达到图文并茂的效果。特别是在一些论文中，以图形作为说明。latex具有强大的图形绘制能力，但是我们这里只介绍如何嵌入外来图片。</p>
<pre><code>% 同样是先包含包
\usepackage{subfig}
\usepackage{wrapfig}    % 图文包围的时候用到
\usepackage{graphicx}
</code></pre><p>下面在上下文中嵌入一张图片：</p>
<pre><code>% 省略上文（此为注释）
\begin{figure}[!htp]
\centering
\includegraphics[angle=10,
width=0.7\textwidth]{pic/junxun.jpg}
\caption{三连南僧激动地和对面二连拉歌}
\end{figure}
% 省略下文
</code></pre><p>效果如下：</p>
<p><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201311/f3333114456e25b0240818f67c08f3ce2013110307432017124.png" alt="插入图片"></p>
<p><code>htp</code>是为了让图片不要落在边界，顶部等特殊地方，而是在正文中。<code>centering</code>死让图片居中，然后是最核心的<code>includegraphics</code>将图片包含进来，并且制定角度为10°，宽度为页面总宽度的70%，<code>caption</code>即为标题。然后注意要闭合嵌入的<code>figure</code>元素。</p>
<h3 id="嵌入文字包围的图片"><a href="#嵌入文字包围的图片" class="headerlink" title="嵌入文字包围的图片"></a>嵌入文字包围的图片</h3><p>那如果要嵌入文字包围的图片，该怎么弄呢？我们要的效果是只在图片存在的地方，文字绕道，但是过了这个位置，则包围了文字。先看别人的<a href="http://www.ctex.org/documents/latex/graphics/node115.html" target="_blank" rel="noopener">经典效果</a>：</p>
<pre><code>\begin{wrapfigure}{r}{4.5cm}
\includegraphics[width=4cm, clip]{pic/face.jpg}
\end{wrapfigure} 
\mbox{}我们的爱情，就像春天盛开的鲜花，无比热情。每当我见到你，就沉醉于其中，快乐无比。我就像那在浅浅柔波中的水草，享受着康桥的水的轻抚。
</code></pre><p>效果如下：<br><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201311/e46b2f87875b8674726d66673259641d2013110308225412500.png" alt="图文混排"><br>如果没有<code>\mbox{}</code>那么就会出现文字出现在图片上的效果。<code>wrapfigure</code>的效果就像是二者可以叠加，也可以互相排斥开来。</p>
<p>更多的latex代码块，还是看教程比较靠谱吧（比如那看起来很高级的数学公式）。</p>
<hr>
<p>end</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/11/03/事件代理实现/" itemprop="url">
                  事件代理实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-11-03T11:26:49+08:00" content="2013-11-03">
              2013-11-03
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2013/11/03/事件代理实现/" class="leancloud_visitors" data-flag-title="事件代理实现">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#事件代理实现</p>
<p>by bibodeng 2013-10-29</p>
<h2 id="事件代理的原理"><a href="#事件代理的原理" class="headerlink" title="事件代理的原理"></a>事件代理的原理</h2><p>所谓事件代理，就是说让另外一个元素，一般是父元素来绑定事件，然后处理的是子元素被点击后的逻辑。这样的目的是减少绑定事件的消耗，因为往往一个父元素下有很多个相同的子元素，它们所绑定的事件也是一样的，故而可以将这个消耗给转移到同一个绑定中，既提升效率，也使得程序变得优雅。我在博客园找到一篇事件代理的<a href="http://www.cnblogs.com/bluedream2009/archive/2010/08/23/1806865.html" target="_blank" rel="noopener">文章</a>，可惜没有注释，而且对于事件代理的原理还需要深入学习一下。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>实现的思路是，对document下的事件进行监听，从事件的源开始向父元素迭代，如果匹配了我们传入的属性值，那么事件将在这个元素进行触发。其本质就是，在根元素绑定事件，传入能够匹配子元素的处理函数。</p>
<pre><code>// 代理事件
// 选择属性，事件类型， 事件处理函数
function delegateEvent(props, type, handler){

    // 能够匹配子元素的根元素事件处理函数
    var fn = function(e){
        e = e || window.e;
        var target = e.target || e.srcElement,    // 获取事件目标
            parent = target,
            p, prop,
            matches = false;


        do{
            matches = false;

            // 对prop的属性进行检查，看是否匹配传入的props参数
            for (p in props){
                if (!props.hasOwnProperty || props.hasOwnProperty(p)){
                    prop = props[p]; // 取得属性值
                    // 若是正则表达式，则使用test，若不是则直接判断是否相等
                    matches = prop.test ? prop.test(parent[p]) : prop === parent[p];
                }
            }
            // 若匹配，则调用handler
            if (matches){
                return handler.call(parent, e);
            }

        }while(parent = parent.parentNode); // 是父元素，一直代理到最顶层 

        return true;
    },

    doc = document;
    // 作对文档的绑定，全部时间代理到docmuent下
    if (doc.addEventListener){    
        doc.addEventListener(type, fn, false);    // 将该代理的事件处理作为一个回调函数传入
    }else{
        if (doc.attachEvent){                    // IE
            doc.attachEvent(&apos;on&apos;+ type, fn);
        } else{                                    // 不支持attach
            var originHandler = doc[&apos;on&apos; + type];    // 原始的处理函数 onload等
            doc[&apos;on&apos; + type] = function(e){
                originHandler.call(this, e);    // 不能覆盖，需要先执行一次原始的处理函数
                fn(e);                            // 再调用代理处理，这样就绑定到doc上了
            };
        }
    }
}; // delegateEvent

// 调用例子
delegateEvent({nodeName:/^li$/i, id:&quot;item_list&quot;}, &apos;click&apos;, function(){
    alert(this.id);
});
</code></pre><h2 id="启发"><a href="#启发" class="headerlink" title="启发"></a>启发</h2><p>出于上面的程序的启发，我们可以写出一个自己的程序，能够针对某一个父元素，代理其子元素的事件。jQuery本身就能够使用形如：<code>$(parent).delegate(&#39;chlidTag&#39;, &#39;type&#39;, function(){})</code>的方式进行代理事件。故而，我们也可以写一个程序进行模拟：</p>
<pre><code>&lt;body&gt;
    &lt;ul id=&quot;item_list&quot;&gt;
        &lt;li id= &quot;1&quot;&gt;1&lt;/li&gt;
        &lt;li id= &quot;2&quot;&gt;2&lt;/li&gt;
        &lt;li id= &quot;2&quot;&gt;3&lt;/li&gt;
        &lt;li id= &quot;2&quot;&gt;4&lt;/li&gt;
        &lt;li id= &quot;2&quot;&gt;5&lt;/li&gt;
        &lt;li id= &quot;2&quot;&gt;6&lt;/li&gt;
        &lt;li id= &quot;7&quot;&gt;7&lt;/li&gt;
    &lt;/ul&gt;
&lt;/body&gt;
</code></pre><p>这是html文档，下面是改进后的javascript：</p>
<pre><code>// 代理目标， 被代理选择器， 事件类型， 事件处理函数
function delegate(deleTarget, props, type, handler){

    // 封装后的处理函数
    var fn = function(e){
        e = e || window.e;
        var target = e.target || e.srcElement,    // 获取事件目标
            parent = target,
            p, prop,
            matches = false;

        //console.log(&quot;target&quot;: target);

        do{
            matches = false;

            // 对prop的属性进行检查，看是否匹配传入的props参数
            for (p in props){
                if (!props.hasOwnProperty || props.hasOwnProperty(p)){
                    prop = props[p]; // 取得属性值
                    // 若是正则表达式，则使用test，若不是则直接判断是否相等
                    matches = prop.test ? prop.test(parent[p]) : prop === parent[p];
                    //console.log(prop, matches, parent);
                }
            }
            // 若匹配，则调用handler
            if (matches){
                return handler.call(parent, e);
            }

        }while(parent = parent.parentNode); // 是父元素，一直代理到最顶层 

        return true;
    };

    // 绑定事件
    try{
        if (deleTarget)
        {
            console.log(deleTarget);
            // 对target进行事件绑定
            if (deleTarget.addEventListener){    
                deleTarget.addEventListener(type, fn, false);    // 将该代理的事件处理作为一个回调函数传入
            }else{
                if (deleTarget.attachEvent){                    // IE
                    deleTarget.attachEvent(&apos;on&apos;+ type, fn);
                } else{                                    // 不支持attach
                    var originHandler = deleTarget[&apos;on&apos; + type];    // 原始的处理函数 onload等
                    deleTarget[&apos;on&apos; + type] = function(e){
                        originHandler.call(this, e);    // 不能覆盖，需要先执行一次原始的处理函数
                        fn(e);                            // 再调用代理处理，这样就绑定到doc上了
                    };
                }
            }
        }
        else
        {
            throw {
                &apos;msg&apos;: &apos;the object is null&apos;
            }
        }
    }
    catch(e)
    {
        alert(e.msg);
    }


};

delegate(document.getElementById(&apos;item_list&apos;), {nodeName: /^li$/i}, &apos;click&apos;, function(){
    alert(this.id);
});
</code></pre><p>当我点击其中子元素时， 可以看到console.log显示的父元素正是item_list，而事件弹出的是子元素的id属性。实验结果如下图：<br><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201311/6cc9d4da53f20d06793cac47445c529e2013110303240430568.png" alt="代理测试效果"></p>
<hr>
<p>end</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/10/27/初识NoSQL/" itemprop="url">
                  初识NoSQL
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-10-27T17:35:23+08:00" content="2013-10-27">
              2013-10-27
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2013/10/27/初识NoSQL/" class="leancloud_visitors" data-flag-title="初识NoSQL">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#初识NoSQL<br>by bibodeng 2013-10-27</p>
<h2 id="Not-only-SQL"><a href="#Not-only-SQL" class="headerlink" title="Not only SQL"></a>Not only SQL</h2><p>之前就接触过NoSQL，但是从来没有再项目实践中使用过。故而，很有必要从入门之初就动手操练一下，就算不太熟练，也能知道其中精华一二。我告诫自己，要紧凑明确，对任何东西都有意识地围绕最核心的东西去发问，凡事问个为什么，不要浪费太多时间在不重要的踌躇中。我之前看过一点NoSQL，毕竟没有什么实战经验，所以忘得也快，现在复习一下。</p>
<p>现代互联应用网对于数据库的要求：</p>
<ol>
<li>低延迟的读写速度：应用快速地反应能极大地提升用户的满意度; </li>
<li>支撑海量的数据和流量：对于搜索这样大型应用而言，需要利用PB级别的数据和能应对百万级的流量; </li>
<li>大规模集群的管理：系统管理员希望分布式应用能更简单的部署和管理; </li>
<li>庞大运营成本的考量：IT经理们希望在硬件成本、软件成本和人力成本能够有大幅度地降低; </li>
</ol>
<p>关系型数据库的优势在于：</p>
<ol>
<li>事务支持 （如MySQL的 InnoDB引擎）</li>
<li>进行复杂查询 （join，几个表联合起来查询）</li>
<li>技术成熟 （oracle， MySQL， SQLServer）</li>
</ol>
<p>NoSQL是一种新型的数据库，和关系型数据库有所不同，在以下方面具有优势:</p>
<ol>
<li>适合分布式，简单的扩展：典型例子是Cassandra，由于其架构是类似于经典的P2P，所以能通过轻松地添加新的节点来扩展这个集群; </li>
<li>快速的读写：主要例子有Redis，由于其逻辑简单，而且纯内存操作，使得其性能非常出色，单节点每秒可以处理超过10万次读写操作; </li>
<li>低廉的成本：这是大多数分布式数据库共有的特点，因为主要都是开源软件，没有昂贵的License成本; </li>
</ol>
<p>以上几点来自互联网，到目前我还没有直观的感受。NoSQL有很多种类型，常见的有Memcached, Redis, MongoDB(和JS有很大渊源)等。</p>
<p><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201310/c7f3d4b3c551949a9f63c2dcc656294e2013102707103327065.png" alt="nosql类型"></p>
<p>键值存储类型的NoSQL数据库，主要是在内存中记录一些经常使用的数据，例如数据库的主键，这就就能够快速存取，而在内存中虽然快，但是存取不够可靠，有可能会丢失，造成数据的不一致性。故而，有一种策略就是当键值修改频率大过某个值的时候，就将缓存的数据给写到磁盘中去。Memcached也可以同MySQL搭配使用（互补），PHP有提供其驱动及接口，我们熟悉的SAE就是采用主从数据库+Memcached的架构。</p>
<p>面向文档的数据库，是将数据以文档的形式存储，其实是类似JSON的格式，也是键值对。</p>
<h3 id="Memcached"><a href="#Memcached" class="headerlink" title="Memcached"></a>Memcached</h3><p>使用散列表的方式存储键值对，全部存储在内存中，故而相当高速，可以很好地改善延迟。</p>
<p><strong>一致性散列技术</strong>：</p>
<p>如果有多台服务器，原理上是使用总数据量除以服务器台数取余来决定散列到哪个服务器，但是当有服务器加入进来时，这个计算到的余数会发生变化。如mod 4 变成 mod5,会有相当数据要重新散列。</p>
<p>而一致性散列将一个范围内的数据，散列到一个圆周上的各个服务器中。并且对于均衡负载，扩展集群，数据迁移等具有良好的支持。并且当有服务器发生故障时，影响的是一部分的数据，有服务器加入进来时，不会因为重新散列找不到数据了，而是只影响少量的数据（需从旧节点迁移到新节点），也即将原来范围内的一部分数据迁移就可以了。如下图所示：</p>
<p><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201310/0053dd31c19d94a02d797b2f513fb733201310270816487506.png" alt="散列一致性"></p>
<p>那么具体它是怎么计算，让部分服务器4的数据散列到服务器5呢？</p>
<p>根据key算出hash值，选择第一个大于该hash值的虚节点server，系统维护了一个server list，每个server具有多个虚节点。也即它的数据不是由服务器数量决定放在哪里的，而是对一个更大的数进行散列，由服务器位置来决定的。</p>
<p><strong>缺陷</strong>：</p>
<p>一定要使用明确的查询条件，就像hash_table数据结构一样，所以不能像关系型一样用<code>LIKE</code>。</p>
<p><strong>启动</strong>：</p>
<pre><code>// 启动   后台运行  端口   用户名    链接数   内存限制
memcached -d -p 12345 -u uname -c 1024 -m 512 
</code></pre><p><strong>使用</strong>：</p>
<pre><code>// 设置键值对 键， 是否压缩， 过期时间戳， 大小
set &lt;key&gt; &lt;flag&gt; &lt;expires&gt; &lt;byte&gt;
&lt;value&gt; // 存储的值

// 获取值
get &lt;key&gt; // 返回key对于的value

// 清空
flush_all 
// flush后数据所占的内存并不会被释放，但会被标记为过期，是不能再被取得了
</code></pre><p><strong>编程语言中的使用</strong>：</p>
<p>请参考<a href="http://www.php.net/manual/zh/book.memcached.php" target="_blank" rel="noopener">PHP memcached手册</a></p>
<pre><code>$options = array( 
    &apos;servers&apos; =&gt; array(&apos;192.168.1.1:11211&apos;), //memcached 服务的地址、端口，可用多个数组元素表示多个 memcached 服务 
    &apos;debug&apos; =&gt; true,                         //是否打开 debug 
    &apos;compress_threshold&apos; =&gt; 10240,             //超过多少字节的数据时进行压缩 
    &apos;persistant&apos; =&gt; false                     //是否使用持久连接 
); 
// 创建 memcached 对象实例 
$mc = new memcached($options); 
// 设置此脚本使用的唯一标识符 
$key = &apos;mykey&apos;; 
// 往 memcached 中写入对象 
$mc-&gt;add($key, &apos;some random strings&apos;); 
// 取出该值
$val = $mc-&gt;get($key); 
// 替换已写入的对象数据值 
$mc-&gt;replace($key, array(&apos;some&apos;=&gt;&apos;haha&apos;, &apos;array&apos;=&gt;&apos;xxx&apos;)); 
// 删除一个值
$mc-&gt;delete($key); 
</code></pre><p>可见，在编程语言中，这样使用memcache数据库已经非常方便了，直接对键值进行存取删除。所以我们就可以在程序中将一些常用的值缓存起来，例如一个获取最新微博的查询，那么我们可以缓存这些微博，当有人刷的时候，就从缓存返回，将大大提升访问速度。</p>
<p>Redis和memcached有点类似，但是它可以进行永久性的键值存储，所以相对又更靠后一点。</p>
<h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><p>MongoDB是无需定义表结构的一种文档型数据库，和关系型一定要确定表的结构，存储各个字段有很大不同。MongoDB是以BSON（binary JSON）的方式来存储数据的，也是以键值的方式对应起来。多个文档可以组成一个集合（对应表），多个集合构成了数据库。    </p>
<p>但是MongoDB不支持JOIN查询以及事务处理。且不是实时写入磁盘，而是有一定的延时。</p>
<p>其MongoDB shell是数据库的管理工具，其脚本语言和JS类似。一些常用的操作可以参考<a href="http://www.cnblogs.com/archie2010/archive/2012/10/07/2712937.html" target="_blank" rel="noopener">例子</a>。以前我一直在担心，这样的键值对存在文档里面，其存取速度会不会很慢呢？它是取得JSON，转化为内存中的对象进行操作的么？</p>
<p>我看到了这样一段话：</p>
<blockquote>
<p>在使用场合下，千万级别的文档对象，近10G的数据，对有索引的ID的查询不会比mysql慢，而对非索引字段的查询，则是全面胜出。 mysql实际无法胜任大数据量下任意字段的查询，而mongodb的查询性能实在让我惊讶。写入性能同样很令人满意。</p>
</blockquote>
<p>具体的测试例子，已经有哥们用号称亿级数据进行了<a href="http://www.cnblogs.com/lovecindywang/archive/2011/03/02/1969324.html" target="_blank" rel="noopener">测试</a>。</p>
<p>后续将会继续深入探索NoSQL数据库。</p>
<hr>
<p>end</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/10/25/梳理常见数据结构/" itemprop="url">
                  梳理常见数据结构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-10-25T15:38:53+08:00" content="2013-10-25">
              2013-10-25
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2013/10/25/梳理常见数据结构/" class="leancloud_visitors" data-flag-title="梳理常见数据结构">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#梳理常见数据结构</p>
<p>by bibodeng 2013-10-25</p>
<h2 id="算法数据囧"><a href="#算法数据囧" class="headerlink" title="算法数据囧"></a>算法数据囧</h2><p>计算机最最重要的是它的硬件能够快速运算，它的软件具有抽象事物的能力。其中算法，是建立在数据结构上的，而对事物的抽象，则是建立在数据结构上的。近期笔试面试中也常考，虽然尤其是对后台的同学来讲，这方面要求会高一点。但是作为计算机学院的学生，很有必要理解一些经典的数据结构，它的最大特征，注意事项，已经常用方法。</p>
<p>我有一次懵了，居然忘了 <code>vector</code> 和 <code>list</code>之间的严格区别，居然闹了笑话。我是一只计算囧。一些程序员追求流行技术的花样，搞得很多框架，模式，有一部分害怕数据，害怕算法，那么终究搞计算机都不是长久之计。</p>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>主要摘录的数据结构有： vector, list, queue, heap, stack, map, set, hashtable。尤其是stack， hashtable，经常出现在笔试题中。</p>
<h3 id="vector-容器"><a href="#vector-容器" class="headerlink" title="vector 容器"></a>vector 容器</h3><pre><code>&gt; * 描述：数组的高级版本，可扩充空间，支持随机存取访问，是一段连续线性的空间。
&gt; * 策略：其实是，当该数组内存不够时，新malloc一块2倍大的内存，将内容复制过去
&gt; * 常见方法： 使用iterator遍历 vector&lt;int&gt;::iterator beg = iv.begin(); *beg 取得内容。
&gt;  arr.push_back(1) 加入， arr.erase(ite) 进行删除
&gt; * 注意： 内存重新复制后迭代子是消失了的
&gt; * 优点： 快速访问，动态扩展
&gt; * 缺点： 内存复制，耗费时间
</code></pre><h3 id="list-链表"><a href="#list-链表" class="headerlink" title="list 链表"></a>list 链表</h3><p><img src="http://daoluan.net/blog/wp-content/uploads/2012/10/list_node.jpg" alt="队列节点"></p>
<pre><code>&gt; * 描述：用指针将前后节点链接起来，指针个数多样，灵活进行插入删除
&gt; * 策略：one by one, hand in hand, 需要一个头指针，由stl维护
&gt; * 常见方法： 迭代器声明方式同vector，lis.push_back(1) 加入， arr.erase(ite) 进行删除
&gt; * 优点： 添加和删除高效
&gt; * 缺点： 不能随机访问，要find()需要遍历，这是硬伤
</code></pre><h3 id="deque-双端队列"><a href="#deque-双端队列" class="headerlink" title="deque 双端队列"></a>deque 双端队列</h3><p><img src="http://daoluan.net/blog/wp-content/uploads/2012/10/deque_in_real.jpg" alt="deque">    </p>
<pre><code>&gt; * 描述：较陌生，它是“分段存储，整体维护”， stack的和queue的母版，看起来复杂好多
&gt; * 策略： 使用map表来进行管理缓存，容易扩展
&gt; * 常见方法： 可以模拟‘随机’访问， de.push_back(), de[i]，*ite访问元素。
&gt; * 迭代器： 见下面的代码
&gt; * 注意： algorithm sort不支持这个迭代器，需要把元素都拿出来放到vector中遍历再放回deque
&gt; * 优点： 强大
&gt; * 缺点： 迭代器较复杂
</code></pre><p>迭代器代码,结合上图进行理解</p>
<pre><code>// 这些是内部维护的，我们不用管
typedef T** map_pointer;    // T是template类型
T* cur;        //指向当前元素
T* first;    //指向缓冲区头
T* last;    //指向缓冲区尾巴
map_pointer node;    //二级指针，指向缓冲区地址表中的位置
</code></pre><h3 id="stack-栈"><a href="#stack-栈" class="headerlink" title="stack 栈"></a>stack 栈</h3><pre><code>&gt; * 描述： 后进先出，一条只容一个人通过的死胡同
&gt; * 策略： 使用deque来实现，限制其只能从一端的尾部进行操作（添加和弹出）
&gt; * 常见方法： push 入栈， pop 出栈，top 顶部
&gt; * 迭代器： 无 不允许遍历
&gt; * 注意： 可选用底层容器实现stack 如 stack&lt;int,list&lt;int&gt;&gt; is;
</code></pre><h3 id="queue-队列"><a href="#queue-队列" class="headerlink" title="queue 队列"></a>queue 队列</h3><pre><code>&gt; * 描述： 一条水管，先进先出
&gt; * 策略： 从尾部添加，从首部弹出
&gt; * 常见方法： push 入队， pop 出队，que.front() 获得头部，que.back()获得尾部
&gt; * 迭代器： 无 不允许遍历
</code></pre><h3 id="heap-堆"><a href="#heap-堆" class="headerlink" title="heap 堆"></a>heap 堆</h3><p>其实它是一种二叉树，一种确保根节点比子节点大的二叉树。我们的堆排序就是利用了这个特性，从而每次从根取出最小或者最大的，从而完成了排序。</p>
<pre><code>&gt; * 描述： 完全二叉树（若二叉树高h，除过最底层h层，其他层1~h-1都是满的；并且最底层从左到右不能有空隙），可以写成数组形式
&gt; * 策略： 保证根是最大或最小的，从而保证堆的性质
&gt; * 常见方法： 上溯：某节点与父节点比较，如果其键值比父节点大，即交换父子节点。从下往上重复； 下溯：与上溯方向相反
&gt; * 迭代器： vector实现max_heap,则为vector迭代器
&gt; * 注意： 可以用数组进行存储，有节点i，那么2i即为其左子结点，2i+1即为其右子结点（正是因为其是满二叉树）
堆带有二叉树的递归性质，故而子堆也具有堆的性质。
</code></pre><h3 id="map-映射"><a href="#map-映射" class="headerlink" title="map 映射"></a>map 映射</h3><p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Red-black_tree_example.svg/450px-Red-black_tree_example.svg.png" alt="红黑树"></p>
<pre><code>&gt; * 描述： 一个键值对应一个实值的映射，不允许键值上的重复，内部是按键值来进行排序存储的，其中键值不允许被更改。
&gt; * 策略： 由非线性空间来存储的， 由RB_TREE（非强平衡树）实现
&gt; * 常见方法： map&lt;int,int&gt; im; im.insert(pair&lt;int,int&gt;(7,700)); 插入对。 遍历
&gt; * 迭代器： map&lt;int,int&gt;::iterator ite； ite-&gt;first, ite-&gt;second 进行访问。
</code></pre><h3 id="set-集合"><a href="#set-集合" class="headerlink" title="set 集合"></a>set 集合</h3><pre><code>&gt; * 描述：顾名思义，不允许重复，底层是由强大的RB_TREE实现的，set中键值就是实值，实值就是键值
&gt; * 策略： 由非线性空间来存储的
&gt; * 常见方法： insert()插入元素， ite.begin(), ite.end() 
&gt; * 迭代器： set&lt;int&gt;::iterator ite; *ite可访问。
&gt; * 注意：不允许更新值
</code></pre><p>对于红黑树，还不算了解，需要找时间彻底地理解map和set的底层。</p>
<h3 id="hash-table-哈希表"><a href="#hash-table-哈希表" class="headerlink" title="hash_table 哈希表"></a>hash_table 哈希表</h3><p>这是笔试面试中考得最多的了，并且一些关于大数据处理问题，需要hash_table来处理，用于解决快速找到所存储的值。没错，数据库中大量应用了hash_table。</p>
<pre><code>&gt; * 描述： 通过对值进行散列，对应到一个连续空间中
&gt; * 策略： 通过计算散列到线性空间，高效查找， 键值对存储。
&gt; * 常见方法： 用hash_table 实现了 hash_set 和 hash_map,故而操作同上
&gt; * 迭代器： STL暂无
&gt; * 注意： 容易发生碰撞，碰撞后往往要线性探测/二次探测/再散列 ，或者是带着一条链表（开链法）。
</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>思愿同学写的 <a href="http://daoluan.net/blog/confidential-stl/" target="_blank" rel="noopener">STL私房菜</a> 大部分图片从这里来，里面的讲解也深入很多。作为一个计算机学生，的确应该对这些基本的数据结构都熟悉，对他们的优点缺点都，适合干啥，都能明确回答，除此之外用这些数据结构来实现点东西，加深印象，我倒是有点重返C++的冲动啊。</p>
<hr>
<p>end</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/10/25/用js实现快排加演示-js排程初探/" itemprop="url">
                  用js实现快排加演示-js排程初探
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-10-25T08:27:58+08:00" content="2013-10-25">
              2013-10-25
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2013/10/25/用js实现快排加演示-js排程初探/" class="leancloud_visitors" data-flag-title="用js实现快排加演示-js排程初探">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="用js实现快排加演示"><a href="#用js实现快排加演示" class="headerlink" title="用js实现快排加演示"></a>用js实现快排加演示</h1><p>by bibodeng 2013-10-24</p>
<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>有很多时候，我们都是需要重新做一个轮子，才知道轮子究竟是什么样子的，然后就可以在下一次碰到这种情况时能够立马写出来，并且能写得很好。本来我打算写一个快排，然后在页面中进行演示，我知道已经有很牛的人实现过了，但是我做这个的时候，遇到了一些困难，使我想起了前段时间想要写某个锁机制队列的时候，后来发现已经有一个同事已经实现了。</p>
<h2 id="实现快排"><a href="#实现快排" class="headerlink" title="实现快排"></a>实现快排</h2><p>先来写个快速排序吧。</p>
<pre><code>var qsort =  function(arr, p, q)
{
    var x;
    if (p &lt; q)    // 需要排序的元素个数不为0
    {
        x = partition(arr, p, q);    // 对数组进行partion处理
        qsort(arr, p, x-1);            // x之前部分  x是该轮确定位置的元素
        qsort(arr, x+1, q);            // 2次递归
    }
};

var partition = function(arr, p, q)
{

    var tmp = 0,
        i     = p,
        j     = q + 1,
        base = arr[p];    // 首元素作为基准

    // 将数组分成两部分，大于base的，小于base的

    while (1)
    {

        while (arr[++i] &lt;= base &amp;&amp; i &lt; q)；

        while (arr[--j] &gt; base);        // 向中间逼近

        if (i &gt;= j)    // 交叉了
        {
            break;
        }
        // 否则就交互两个数，正好比base大的和比base小的换了一下

        // swap(arr[i], arr[j]);
        tmp = arr[j];
        arr[j] = arr[i];
        arr[i] = tmp;
    }
    //     交互基准值和中值

    arr[p] = arr[j];    // 将中间元素放到首部
    arr[j] = base;        // 将基准元素放到中间
    return j;        // 返回这个位置
};
</code></pre><p>没什么特别的，几乎和C++的一模一样，其中swap在js下，因为不是传入参数不是引用类型，故而不起作用，故而直接引入tmp变量进行交换。下面是调用部分：</p>
<pre><code>$.(function(){
    // 进行测试

    var myArr = [],
        total = 50；

    for (var i = 0; i &lt; total; i++)
    {
        myArr.push(parseInt((Math.random() * 450)));    // 0 - 450
    }

    // 绘制方格
    qsort(myArr, 0, myArr.length-1); 
});
</code></pre><p>为了能够体现出排序的可视化效果，我打算绘制一些小方格排列在一起，就像下面这样：</p>
<p><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201310/6666f6b0ea50298df61bfe5cad57efce2013102411275015768.png" alt="排序可视化"></p>
<p>实现的代码并不麻烦，在ready中加入绘制方格的代码：</p>
<pre><code>// 绘制方格
var str = &apos;&apos;;
for (var j = 0; j &lt; total; j++)
{
    str += &quot;&lt;li class=&apos;normal&apos; style=&apos;height:&quot;+myArr[j]+&quot;px;&apos;&gt;&lt;/li&gt;&quot;;    // 添加元素
}
$partent.html(str);
var $list = $(&apos;#sort_list&apos;).find(&apos;li&apos;);
</code></pre><p>其html代码，主要是提供容器，还有CSS样式。</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;style type=&quot;text/css&quot;&gt;
.normal{
    background-color: #222;
}

.base{
    background-color: #f22;
}

.selected{
    background-color: #22f;
}

#main{
    width: 1000px;
    height: 600px;
    margin: 10px auto;
    -webkit-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    transform: rotate(180deg);
}

#sort_list li{
    float: left;
    width: 10px;
    margin: 1px;
    list-style: none;
}

&lt;/style&gt;
&lt;title&gt;快速排序&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;main&quot;&gt;
        &lt;ul id=&quot;sort_list&quot;&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>接下来就要实现排序过程中的动态效果了，这是一个很麻烦的事情。初步实现的例子是<a href="">这样的</a>。尽管我试着在<code>partition</code>每一步中进行延时，但是排序算法始终太快了，而使用setTimeout的方法进行异步延时，得到的动画效果将和排序结果不兼容的。修改后的代码，增大了递归的时间间隔，但是夹逼的效果闪烁太快了，没有流动的动画效果。这其实是因为代码执行和DOM元素操作不同步引起的。</p>
<pre><code>var qsort =  function(arr, p, q)
{
    var x;
    if (p &lt; q)    // 需要排序的元素个数不为0
    {
        x = partition(arr, p, q);    // 对数组进行partion处理

        setTimeout(function(){
            qsort(arr, p, x-1);        // x之前部分  x是该轮确定位置的元素
        }, 1000);

        setTimeout(function(){
            qsort(arr, x+1, q);        // 2次递归
        }, 2000);

    }

    console.log(&apos;after sort&apos;, arr);
};
</code></pre><p>并且setTimeout这东西，在循环下，是很耗费内存的，会导致页面奔溃，并且它之内将逻辑包围在一个函数参数里面，不太好。当把for循环换成setInterval调用时，元素操作效果倒是流畅了，但是排序结果却不正确了。原因是后续代码已经开始运行了。</p>
<h2 id="异步的麻烦与解决办法"><a href="#异步的麻烦与解决办法" class="headerlink" title="异步的麻烦与解决办法"></a>异步的麻烦与解决办法</h2><p>异步的麻烦，是真麻烦。我思考了一下，将排序算法和DOM操作混在一起是很野蛮的做法，没有做到数据加工和体现的分离。而当前状态又需要重绘，才能体现出其动态效果，但是重绘的代价也太大了，左思右想，没有想到好的解决办法，于是找到陈皓提到的日本程序员写的<a href="http://coolshell.cn/articles/3933.html" target="_blank" rel="noopener">排序可视化</a>，太强大了，效果也是一级棒，不过要细细剖析源码才知道它是如何实现的，这个改天再一探究竟，今天我要隆重介绍一下一个相当优雅的排程小程序，个人觉得写得相当优雅。</p>
<p>我们做很多编程工作时，往往想要同步（这里的同步指的是确定顺序，而不是不确定），例如在进行ajax请求时，回调结果往往要等一段时间才能返回，但是我们的程序的<code>return</code>却不知道要从哪里返回，如果在回调的外面，则等不到结果就返回了，如果在回调函数里面，则又返回不到正确的地方，这个时候就很有必要同步了。而一个排程的程序，对各个操作进行同步互斥，则可以让它们乖乖一个接一个按顺序执行，这就好比操作系统里面对资源的锁。具体可以参看<a href="http://myunlessor.me/" target="_blank" rel="noopener">myunlessor写的排程策略详解</a>。直接上代码吧：</p>
<pre><code>// 排程策略 - 全局定义
var schedule = (function (self) {
  var paused = false, // 标记状态
      queue  = [];     // 队列

  // 入队
  self.join = function (fn, params) {
    params = params || {};
    var args = [].concat(params.args);

    queue.push(function (_) {
      _.pause();
      setTimeout(function () {
        fn.apply(params.context || null, args);
        _.resume();
      }, params.delay || 1);
    });

    return exec();
  };

  self.pause = function () {
    paused = true;  // 忙碌
    return this;
  };

  // ready and call next
  self.resume = function () {
    paused = false; // 空闲
    setTimeout(exec, 1);
    return this;
  };

  function exec() {
    if (!paused &amp;&amp; queue.length) {
      queue.shift()(self);  // 出队
      if (!paused) self.resume();
    }
    return self;
  }

  return self;
}(schedule || {}));    // 立即执行，self就是schedule本身
</code></pre><p>我对着这个程序看了十来分钟，越看越有味道，从这个程序中可以看到javascript的很多good part,暂时没有看到缺陷，例如[]，用成了活生生的队列，使用push和shift进行入队出队操作。还有闭包，直接返回一个self，本身参数传的是schedule，而schedule本身是刚刚定义的，需要赋值的，这一切看起来多么地神奇，还有返回this，强大的链式调用，有木有，额有点跑题了。下面我们就应用到我们的排序中：</p>
<pre><code>var qsort =  function(arr, p, q)
{
    var x;
    if (p &lt; q)    // 需要排序的元素个数不为0
    {
        x = partition(arr, p, q);    // 对数组进行partion处理

        schedule
        .join(qsort,{
            delay: 100,
            args: [arr, p, x-1]
        })
        .join(qsort, {
            delay: 100,
            args: [arr, x+1, q]
        });
    }
};
</code></pre><p>一切都相当优雅。当我打开浏览器测试时，发现，有了排程，而不是死板的setTimeout，动画变得流畅了很多。接下来的目标是接着优化<code>partition</code>里面的代码，使得这个过程也看起来很流畅。</p>
<pre><code>var partition = function(arr, p, q)
{

    var tmp = 0,
        i     = p,
        j     = q + 1,
        base = arr[p];    // 首元素作为基准

    $list.attr(&apos;class&apos;, &apos;normal&apos;);
    schedule
    .join(showBase, {
        delay: 0,
        args: [p]
    });

    while (1)
    {

        while (arr[++i] &lt;= base &amp;&amp; i &lt; q)
        {
            ;// 只要是小于base且没到结尾就一直前进
            schedule.
            join(moveSelectedRight,{
                delay: 50,
                args : [i]
            });
        }

        while (arr[--j] &gt; base){
            schedule.
            join(moveSelectedRight,{
                delay: 50,
                args : [j]
            });
        }

        if (i &gt;= j)    // 交叉了
        {
            break;
        }
        // 否则就交互两个数，正好比base大的和比base小的换了一下

        tmp = arr[j];
        arr[j] = arr[i];
        arr[i] = tmp;

        // 交换两元素的位置，这里耍了点小聪明，用高度代替
        schedule
        .join(exchangeHeight,{
            delay: 50,
            args: [$list.get(i), $list.get(j)]
        });
    }


    //     交互基准值和中值

    arr[p] = arr[j];    // 将中间元素放到首部
    arr[j] = base;        // 将基准元素放到中间

    schedule
    .join(exchangeHeight,{
        delay: 50,
        args: [$list.get(p), $list.get(j)]
    });

    $list.attr(&apos;class&apos;, &apos;normal&apos;);
    return j;        // 返回这个位置
};

// 将标志右移 只改颜色
var moveSelectedRight = function(i){
    $(&apos;.selected&apos;).attr(&apos;class&apos;, &apos;normal&apos;);
    $($list.get(i)).attr(&apos;class&apos;, &apos;selected&apos;);
};

// 将标志左移
var moveSelectedLeft = function(j){
    $(&apos;.selected&apos;).attr(&apos;class&apos;, &apos;normal&apos;);
    $($list.get(j)).attr(&apos;class&apos;, &apos;selected&apos;);
};

var showBase = function(base){
    $(&apos;.base&apos;).attr(&apos;class&apos;, &apos;normal&apos;);
    $($list.get(base)).attr(&apos;class&apos;, &apos;base&apos;);        // 将base染色
};

// 交换两个元素的位置 A 前 B 后
var exchange = function(elemA, elemB){
    var m = $(elemA).next(),
        n = $(elemB).prev();

    console.log(&apos;交换&apos;);
    setTimeout(function(){
        $(elemB).insertBefore(m);
        $(elemA).insertAfter(n);
    }, 50);

};

// 只交换两者的高度
var exchangeHeight = function(elemA, elemB)
{
    var tmp = parseInt($(elemA).css(&apos;height&apos;));

    $(elemA).css(&apos;height&apos;, $(elemB).css(&apos;height&apos;));
    $(elemB).css(&apos;height&apos;, tmp+&apos;px&apos;);
};    
</code></pre><p>最后的效果，可以看<a href="http://bibodeng.com/bibodeng/js-algorithms/qsort/index.html" target="_blank" rel="noopener">这里</a>。但是显然这种DOM操作和算法混在一起的日子是不长久的，鬼群里面有人建议使用<a href="http://d3js.org/" title="jquery-d3插件" target="_blank" rel="noopener">D3一个数据DOM体现的插件</a>，有待继续探索。勇敢的骚年，快去创造奇迹！！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://myunlessor.me/blog/2013/06/04/strategy-for-scheduling-javascript-asynchronous-code/" target="_blank" rel="noopener">js排程策略</a></p>
<p><a href="http://coolshell.cn/articles/3933.html" target="_blank" rel="noopener">可视化排序</a></p>
<p><a href="http://d3js.org/" target="_blank" rel="noopener">jQuery D3</a></p>
<hr>
<p>end</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/10/23/CSS3 3D六面体效果/" itemprop="url">
                  CSS3 3D六面体效果
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-10-23T17:55:01+08:00" content="2013-10-23">
              2013-10-23
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2013/10/23/CSS3 3D六面体效果/" class="leancloud_visitors" data-flag-title="CSS3 3D六面体效果">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="CSS-3D效果"><a href="#CSS-3D效果" class="headerlink" title="CSS 3D效果"></a>CSS 3D效果</h1><p>by bibodeng 2013-10-23</p>
<h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>无意之中看到<a href="http://beiyuu.com/" target="_blank" rel="noopener">beiyuu</a>写的CSS3动画详解，而我之前没有怎么系统学习过CSS3和HTML5，故而对其炫酷的效果非常动心，并且觉得这个技术在一些地方肯定非常棒。他的讲解例子很丰富，但是我还是花了一些功夫去理解。轻松获得的东西，也容易轻松失去，如果其中过程很难忘，那么的确可以学到一些东西。而这个折腾的过程，我也动手亲自实践了一下，一起来吧！</p>
<p><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201310/8d3daa4bfcfccc75819d06cf1f79bce42013102307565821497.png" alt="成为最强的人"></p>
<p>一直觉得很自卑，想要成为一个很强的人 : P</p>
<h2 id="CSS3-3D"><a href="#CSS3-3D" class="headerlink" title="CSS3 3D"></a>CSS3 3D</h2><p>如果突然给个例子你，很可能会消磨掉你的耐性，一切应当在愉悦的氛围下学习，但是也要留下深刻的印象，其基础是理解，这样很容易就知道如何写一个3D的东西了，将来也可以写更加复杂的效果（如果你数学好的话）。</p>
<h3 id="3D坐标系"><a href="#3D坐标系" class="headerlink" title="3D坐标系"></a>3D坐标系</h3><p>计算机技术源于数学，而3D坐标系，是3D空间的基础。2D空间中，容易理解，就是一个十字，横向为x轴，纵向为y轴。如下：</p>
<p><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201310/282308e18cf25d10bf245c2d511a642d2013102308173126290.png" alt="二维坐标轴"></p>
<p>三维的坐标轴稍有不同，举起你的右手，手心对着你的脸，大拇指头就是x, 中指是z， 而食指是y轴。如下图所示：</p>
<p><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201310/6b2ef4260a2a5c0d2e4525830869303b2013102309193132740.png" alt="三维坐标轴"></p>
<p>下面将会理解怎么布局3维的东西，这个图对于理解rotate（旋转）， transform（位移）都将有帮助。也可以看看这里的<a href="http://desandro.github.io/3dtransforms/examples/cube-01-steps.html" target="_blank" rel="noopener">分步过程</a>,分为以下步骤：</p>
<ol>
<li>形成平面叠加</li>
<li>平面旋转，上下左右，前后，但是还有一些重叠在一起</li>
<li>对平面进行位移，形成3维视觉效果</li>
<li>整体旋转3D物体</li>
</ol>
<h3 id="将元素转化为3D空间"><a href="#将元素转化为3D空间" class="headerlink" title="将元素转化为3D空间"></a>将元素转化为3D空间</h3><p>假设我们正在做一个骰子一样的六面体，我们希望它的六个面能够像坐标中的那个立方体一样。首先写出如下的html代码，构建出基本元素。</p>
<pre><code>&lt;div id=&quot;cube-con&quot;&gt; &lt;!-- 主容器 --&gt;
    &lt;div id=&quot;cube&quot;&gt;
        &lt;figure class=&quot;front&quot;&gt;1&lt;/figure&gt;
        &lt;figure class=&quot;back&quot;&gt;2&lt;/figure&gt;
        &lt;figure class=&quot;right&quot;&gt;3&lt;/figure&gt;
        &lt;figure class=&quot;left&quot;&gt;4&lt;/figure&gt;
        &lt;figure class=&quot;top&quot;&gt;5&lt;/figure&gt;
        &lt;figure class=&quot;bottom&quot;&gt;6&lt;/figure&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;cube_btns&quot;&gt;    &lt;!-- 用于控制翻转的按钮,供js调用 --&gt;
    &lt;input type=&quot;button&quot; value=&quot;前&quot; id=&quot;cube_btn1&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;后&quot; id=&quot;cube_btn2&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;右&quot; id=&quot;cube_btn3&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;左&quot; id=&quot;cube_btn4&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;上&quot; id=&quot;cube_btn5&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;下&quot; id=&quot;cube_btn6&quot;&gt;
&lt;/div&gt;
</code></pre><p>下面要写CSS3代码，整出3D效果：</p>
<pre><code>#cube-con {
    width: 200px;
    height: 200px;
    position: relative;
    margin: 40px auto 40px;
    -webkit-perspective:1000px;    /*从多远的距离进行观察，值越大，立体部分拉升越小*/
       -moz-perspective:1000px;
         -o-perspective:1000px;
            perspective:1000px;
}
#cube {
    width: 100%;
    height: 100%;
    position: absolute;
    -webkit-transform-style:preserve-3d; /*转换成3D空间！*/
       -moz-transform-style:preserve-3d;
         -o-transform-style:preserve-3d;
            transform-style:preserve-3d;
    -webkit-transition:-webkit-transform 1s;
       -moz-transition:-moz-transform 1s;
         -o-transition:-o-transform 1s;
            transition:transform 1s;
    -webkit-transform:translateZ( -100px );
       -moz-transform:translateZ( -100px );
         -o-transform:translateZ( -100px );
            transform:translateZ( -100px );
}

#cube figure {
    width:196px;
    height:196px;
    display:block;
    margin: 0; /* 如果没有这个，各个面可能不居中，导致翻转不绕中心*/
    position:absolute;    /*应该使用绝对定位，因为它已经不是DOM流的形式了，更像float*/
    border:2px solid black;
    color:#fff;
    font-size:130px;
    font-weight:bold;
    text-align:center;
    line-height:190px;
    opacity:0.8;
}
</code></pre><p>所谓<code>translateZ</code>就是指在该轴方向进行位移，负值表示往正方向相反的方向移动，故而<code>translateZ(-100px)</code>的作用是往后推100个像素，浏览器会自动进行根据拉伸进行计算实际的尺寸。在这里是为了中点维持在中心，因为待会各个面还需要位移，以使得体现立体效果。</p>
<h3 id="移动，旋转元素"><a href="#移动，旋转元素" class="headerlink" title="移动，旋转元素"></a>移动，旋转元素</h3><p>现在所有的面都像一个普通平面图形一样面对着我们，接着对各个面进行处理，把各个面给拉开距离，并且旋转到合适的角度。俯视示意图如下：</p>
<p><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201310/27945e857498ff05eb14e830e98e84a3201310230919311155.png" alt="四面示意图"></p>
<p>其中正方体的边长为<strong>200px</strong>。</p>
<pre><code>#cube .front {        /*绕y轴旋转为0，故而正对我们，并且向前一步走（100像素）*/
    background:#1abc9c;
    -webkit-transform:rotateY(0deg) translateZ(100px);
       -moz-transform:rotateY(0deg) translateZ(100px);
         -o-transform:rotateY(0deg) translateZ(100px);
            transform:rotateY(0deg) translateZ(100px);
}
#cube .back {       /*绕x轴旋转180度，并且向前位移100，这个稍微有点难理解，看正文*/
    background:#3498db;
    -webkit-transform: translateZ(100px) rotateX(180deg);
       -moz-transform: translateZ(100px) rotateX(180deg);
         -o-transform: translateZ(100px) rotateX(180deg);
            transform: translateZ(100px) rotateX(180deg);
}
#cube .right {        /*绕y轴转90度*/
    background:#8e44ad;
    -webkit-transform: translateZ(100px) rotateY(90deg);
       -moz-transform: translateZ(100px) rotateY(90deg);
         -o-transform: translateZ(100px) rotateY(90deg);
            transform: translateZ(100px) rotateY(90deg);
}
#cube .left {        
    background:#34495e;
    -webkit-transform: translateZ(100px) rotateY(-90deg);
       -moz-transform: translateZ(100px) rotateY(-90deg);
         -o-transform: translateZ(100px) rotateY(-90deg);
            transform: translateZ(100px) rotateY(-90deg);
}
#cube .top {        
    background:#f39c12;
    -webkit-transform: translateZ(100px) rotateX(90deg);
       -moz-transform: translateZ(100px) rotateX(90deg);
         -o-transform: translateZ(100px) rotateX(90deg);
            transform: translateZ(100px) rotateX(90deg);
}
#cube .bottom {        
    background:#c0392b;
    -webkit-transform: translateZ(100px) rotateX(-90deg);
       -moz-transform: translateZ(100px) rotateX(-90deg);
         -o-transform: translateZ(100px) rotateX(-90deg);
            transform: translateZ(100px) rotateX(-90deg);
}
</code></pre><p>重点解释一下<code>translateZ(100px)</code>,尤其是在背面的时候，不是应该后退一步么？那是因为它的角度的问题，想象一下你站在原地，要以原点为对称点翻个身到后面的100px距离处，是不是先要向前一步走，然后翻到后面去。这就是为什么是向前一步走，而不是退后一步了。侧面也很好理解，由于本身是在xy平面的（0,0）处的，所以要往前站半个边长，才能让x轴正对身体中部。这些完全是坐标的关系导致的必须遵守的规则。</p>
<p>这样六个面就形成了。下面进行整体的旋转。</p>
<h3 id="整体的旋转"><a href="#整体的旋转" class="headerlink" title="整体的旋转"></a>整体的旋转</h3><p>是对cube整体的旋转和位移，六个面作为一个整体一起运动。注意是对cube添加css布局类。</p>
<pre><code>#cube.show-front {
  -webkit-transform:translateZ(-100px); /* -100px 表示将cube拉后到z为0的平面，这样大小就不会变化了*/
     -moz-transform:translateZ(-100px);
       -o-transform:translateZ(-100px);
          transform:translateZ(-100px);
}
#cube.show-back {
  -webkit-transform:  rotateX(-180deg) translateZ(-100px);
     -moz-transform: rotateX(-180deg) translateZ(-100px);
       -o-transform: rotateX(-180deg) translateZ(-100px);
          transform: rotateX(-180deg) translateZ(-100px);
}
#cube.show-right {
  -webkit-transform: rotateY(-90deg) translateZ(-100px);
     -moz-transform: rotateY(-90deg) translateZ(-100px);
       -o-transform: rotateY(-90deg) translateZ(-100px);
          transform: rotateY(-90deg) translateZ(-100px);
}
#cube.show-left {
  -webkit-transform: rotateY(90deg) translateZ(-100px);
     -moz-transform: rotateY(90deg) translateZ(-100px);
       -o-transform: rotateY(90deg) translateZ(-100px);
          transform: rotateY(90deg) translateZ(-100px);
}
#cube.show-top {
  -webkit-transform: rotateX(-90deg) translateZ(-100px);
     -moz-transform: rotateX(-90deg) translateZ(-100px);
       -o-transform: rotateX(-90deg) translateZ(-100px);
          transform: rotateX(-90deg) translateZ(-100px);
}
#cube.show-bottom {
  -webkit-transform: rotateX(90deg) translateZ(-100px);
     -moz-transform: rotateX(90deg) translateZ(-100px);
       -o-transform: rotateX(90deg) translateZ(-100px);
          transform: rotateX(90deg) translateZ(-100px);
}
</code></pre><p>想象一下，怎样翻转会让各个面转动到面对着你。以<code>.show-right</code>为例吧，我们需要让它绕y轴反方向转动90度，总之面是怎么旋转的，我们现在只要对cube反着来就可以了。</p>
<pre><code>/*右面的旋转角度*/
rotateY(90deg)

/*把它转回正面，我们就反着来*/
rotateY(-90deg)
</code></pre><p>这样就能达到整体的效果了。剩下的就是绑定事件，需要旋转时，给它设置对应的css类就ok了。下面是事件绑定的js代码：</p>
<pre><code>$(function(){
    // 省略其他
    // for cube
    var cubeClassArray = [
        &apos;show-front&apos;,
        &apos;show-back&apos;,
        &apos;show-right&apos;,
        &apos;show-left&apos;,
        &apos;show-top&apos;,
        &apos;show-bottom&apos;
    ];

    $(&apos;#cube_btns input&apos;).click(function(){
        var i = $(this).index();
        $(&apos;#cube&apos;).attr(&apos;class&apos;, cubeClassArray[i]);    // 设置cube的css类，进行旋转
    });

});
</code></pre><p>好，一切大工告成了，你可以看到一个很酷的旋转六面体。</p>
<p><img src="http://www.bibodeng.com/content/plugins/kl_album/upload/201310/51d8fd0bc5f9f4258f731e504edbd0572013102309512713254.png" alt="3D cube"></p>
<p>参考：</p>
<ul>
<li>了解transform和animation<a href="http://beiyuu.com/css3-animation/" target="_blank" rel="noopener">css3动画详解</a></li>
</ul>
<hr>
<p>end</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/10/20/十月小记/" itemprop="url">
                  十月小记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-10-20T09:46:45+08:00" content="2013-10-20">
              2013-10-20
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2013/10/20/十月小记/" class="leancloud_visitors" data-flag-title="十月小记">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="十月小记"><a href="#十月小记" class="headerlink" title="十月小记"></a>十月小记</h1><p>by bibodeng 2013-10-19</p>
<h2 id="实习"><a href="#实习" class="headerlink" title="实习"></a>实习</h2><p>在这几个月里，发生的最重要的事情就是实习。从七月初，到前几天离职，3个月零15天。也算是蛮长的了。在实习中我尝试到了很多不同的东西，认识了一些有趣的人。同时也对我的身心有了一定的冲击，有健康的和不健康的。</p>
<h3 id="身体"><a href="#身体" class="headerlink" title="身体"></a>身体</h3><p>首先说说身体，在学校上课，我们都舒舒服服地坐着，而且不会一整天都呆在电脑面前。但是工作不一样，几乎一天八小时都坐在电脑面前，盯着屏幕，对于眼睛和脊椎都是很大的考验。刚开始来的时候，用的是台式机，台式机比较高，对坐姿要求比较高，但是累了之后一般姿势就没有那么好了，所以容易扭曲，导致脖子会有酸痛，一开始的时候这种感觉特别强烈。后来，我用自己的笔记本办公，这样脖子好受一些了，因为桌子比椅子要高出许多，用台式的时候感觉还行，但是用笔记本的时候，发现自己的手肘部分会长期支撑上半身，变得很疼痛。而且由于手硬，柔韧性不太好，所以敲键盘多了也会产生一定的疼痛。当然这也是和键盘的尺寸有关系的，手指太长了对于打字不是太方便，另外也和个人的打字习惯有关系，我习惯用小指来按<code>Ctrl</code>键，而且养成了保存的习惯，所以非常容易劳累。很奇特的是，当我全神贯注在工作的时候，往往注意不到这种不适，在一个问题反复折腾的时候，就会比较容易累。值得一提的是，长期在电脑面前，我的眼睛居然还行，并没有觉得特别地劳损。但是当看到一些不近视的程序员同事们的时候，还是会有点诧异。</p>
<p>工作后，很明显的一件事就是锻炼减少了，很多人一周都不锻炼一次，最多去打一次羽毛球或者乒乓球，当需求催得紧的时候，整个人都投入进去了，很难抽出时间去搞运动。健康是很重要的，即使现在看起来运动的要求并不紧迫，但是等到肥胖来临，或者健康状况下降的时候，我们就会后悔了。人是首先健康地生活，然后才能健康地工作。</p>
<h3 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h3><p>工作中，有压力的情况下，技能习得的效率是比平时在校园里悠闲自在来得高一点。我会不自主地花时间去解决我的剩余的功能实现以及debug。任何事情，只要你开始花时间去了解它，那么你就已经开始在解决问题了。第一步往往很重要，它标志着你克服了心理上的障碍，动员了全身力量去完成目标。这个力量是非常巨大的，尤其是在压力大增的情况下，你甚至会比平常更加出色地完成任务，我自己也曾暗暗赞叹自己居然能够想出这么好的解决办法。这应该归功于我的头脑，以及我付出的艰辛。</p>
<p>最好的技能习得，就是在实践中学习。在学校，比较偏重的是理论的学习，除了实验课，我们都懒得写代码，但是在公司，没有代码就没有进度。而且，我们从别人那里，或者书籍文档中，会了解到一些新的东西，补充我们原来的不成熟的认识。项目中的需求，也驱动着我去学习新的东西，例如flash接口，canvas等等，还有一大部分就是兴趣驱使。<em>问题是进步的重要的标志</em>，有了问题，就标志着我们要去解决问题，也就会使得我们对知识及技能更加熟练，认识更加深刻。如果没有问题，那么必定是没有做多少思考，慢慢会在工作的重压中变得越来越愚钝。问题本身也推动着我们的进步，遇到问题应该高兴，弄懂之后，便进步了一点（举个例子，如果不是为了解决一个布局问题，我也不会从七宝那里得知clear属性是清除自身的浮动，而不是清除别人的浮动）。</p>
<h2 id="领悟"><a href="#领悟" class="headerlink" title="领悟"></a>领悟</h2><p>前几天看到一篇陌陌的同学写的文章<a href="http://craylin.blog.163.com/blog/static/169631722201261421149449/" target="_blank" rel="noopener">写给进步缓慢却全然不知的IT人</a>，他说的几句话打醒了我：</p>
<blockquote>
<p>这些孩纸们入了某一行，涉足某个领域，却从没想过这个领域最高境界是啥样子，最牛逼的几个人是谁。他们的评判标准就只看是否满足领导的要求，是否比身边另两个笨蛋利索些，是否成为他们的技术指导。</p>
</blockquote>
<p>的确，我们接触一个行业，一种技能，都不想想最高境界是什么，于是狭隘地以为做到还行就可以了，而且完全不知道自己和更高层次的人的差别。这是非常恐怖的事情，更加坚定我心中<strong>眼界</strong>在学习和生活中的重要性。同时也给我们一个启发，学习一个专业的方法应该是如何的？</p>
<ul>
<li>了解它是什么能干什么 （历史）</li>
<li>最牛的人是谁，怎么向他们靠拢</li>
<li>踏实去做</li>
</ul>
<p>我连夜找出了几个在前端开发领域的大牛，如 玉伯，js编程精粹作者 等等，这里有一个在线ppt，给你一个发现web前端大牛的机会： <a href="https://speakerdeck.com/josephj/f2e-the-keystone" target="_blank" rel="noopener">前端开发实务</a>。关注大牛，等于你多了一个武功盖世的导师，给你指点了方向。那你自然就会朝着牛逼的方向前行。我自己也发现，比平时更喜欢上博客园了，而不是去51CTO, 我还看了一句话 “来博客园的都是大牛，要么就是朝着大牛发展的小牛”，看着这句话，我笑了。某个时刻，我感觉到自己就要朝着牛逼发展了，心中非常地激动，好像浑身都在升华一样，这种感觉就像枯草盼望到了春雨，浑身都在萌动，小宇宙在爆发。</p>
<p>曾经有一段日子，我每天都很忙，其实实习期间，我养成了早起的习惯（确切地说，我大学期间就是这个习惯），往往六七点就起来了，静坐一下，写一下日记，然后就洗涮出发赶公车。我很早就去到公司，然后浏览一下博客，写点代码。但是我们部门的总监，比我还早，7点多就到公司了，有几次我在等公交的时候遇见他，还对了一下时间，我的快了十多分钟，他意味深长地说了一句“时间还是要调准的，否则会错过很多事情”，然后就互相问了一下那么早到公司都做什么，我问他要不要写代码，他说还要写代码。而且每次碰到他，他都说“好好努力，争取留在公司”。</p>
<p>忙碌的日子，非常充实，想的东西也非常实在。有几次回来已经非常累了，倒在床上睡着了，第二天才起来洗澡。那时候，感觉自己和时间融合在了一起，随着它一起流动。我很享受这样的时光，也很喜欢深圳的秋天，早上吹一阵风，就能精神一整天。而晚上搭公车回家，也会觉得异常放松，连皮肤也变得细腻起来，这些微妙的感觉不知道别人有没有。深圳还是挺宜居的，几次在街上漫步都感觉非常惬意，但是没有人陪，走了几步就掉头回宿舍了。</p>
<h3 id="连接万岁"><a href="#连接万岁" class="headerlink" title="连接万岁"></a>连接万岁</h3><p>人是自然的一部分，其使命是与自然联接，融于一体，人与人之间，也应该连接起来（想象一下阿凡达怎么驾驭飞龙的）。如果你掌握一样纯熟的技能，你就好像与这个技能本身连接起来，并且对于它的本质具有敏感的直觉。凡事就是这样，open your mind,然后你才可以接受各种信号。良好的情景，对于连接具有很大的沉浸作用。这就是为什么嘹亮军歌让你不自觉挺直身体，而太极音乐则让你思绪飘渺，动作自然流畅。</p>
<p>再来谈谈人与人的联接，某天看到一句这样的话：</p>
<blockquote>
<p>爱是感应的能力，和response更贴近</p>
</blockquote>
<p>对此，我深以为然，没有感应了，那就没有感情了，如果有只能算作留恋。人与人之间，就好像两台电脑，要互相都打开心灵窗口，才能沟通。平常与人交往中，我们常常send,receive, 要是只有send，没有receive，那么就没有了下文。这是断开了连接，失去了感应的能力，人际关系也渐渐淡了。还有一种情况，也很糟糕，那就是交际中带有负面的情绪，例如猜忌，尴尬，则会严重影响沟通的质量，因为这本身也是一种关闭，摒弃了坦诚的沟通。如果不予以改善的话，必定会导致关系的破裂，而坦诚的沟通又会修复这样的破裂。通信的时机也很重要，要是对方处在忙碌时期，心情急躁，根本无暇理睬稍微次要的东西，那么这样的沟通也将沦落成为敷衍。人们对于敷衍，可是非常地敏感的。从对方的眼神中，言语中很容易就察觉到细微的不耐烦，如果心不在焉那还不如不说话。下面总结一下，质量不高的沟通：</p>
<ul>
<li>不确定，不安全的 （猜疑/尴尬/恐惧）</li>
<li>传输质量不高的（心不在焉）</li>
<li>不可理解的 （都不懂，对牛弹琴啊）</li>
</ul>
<p>沟通的内容不在于聊什么，最重要的是通信双方的互相信任，敞开心扉。即使是与物打交道的时候，即使最死的东西，如石头，它也有它的表达，如果我们心灵中对其有发现美的眼睛，那么也会对其动心。而你也会以为它其实是有神韵的。和人交流会更加复杂，但是总体的原则就是保持阳光，和谐的心态，避开上面所说的负面情绪，则关系就不会降温，而质量也会一直较高。所以啊，男生表白，不要搞得尴尬，恐惧，人最首要的需求是生存，如果都没有安全感，对方很容易就say no的。也不要过分去猜测对方的意图，不要过分的压迫感，顺其自然就好了，营造一个良好的氛围，比啥都重要。</p>
<hr>
<p>end</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/10/10/理解JSONP原理与使用/" itemprop="url">
                  理解JSONP原理与使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-10-10T23:51:00+08:00" content="2013-10-10">
              2013-10-10
            </time>
          </span>

          

          
            
          

          
	
          
          
             <span id="/2013/10/10/理解JSONP原理与使用/" class="leancloud_visitors" data-flag-title="理解JSONP原理与使用">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="关于JSONP"><a href="#关于JSONP" class="headerlink" title="关于JSONP"></a>关于JSONP</h1><p>by bibodeng 2013-10-10</p>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>之前也不知道什么东东是JSONP（尽情笑话我吧）,只是听我的导师说前端和后台分开放，但是其绑定了不同的子域名，于是需要使用jQuery里面的JSONP支持，给服务端发送请求的时候给一个callback=?参数，然后返回的时候用callback包裹里面的数据。当我看到这篇关于 <a href="http://www.ibm.com/developerworks/cn/web/wa-aj-jsonp1/" target="_blank" rel="noopener">跨域JSON请求</a> 的文章的时候我才理解了这个做法。</p>
<h2 id="什么是JSONP"><a href="#什么是JSONP" class="headerlink" title="什么是JSONP"></a>什么是JSONP</h2><p>到底什么是JSONP，其原理如何呢？<br>JSONP 是英文 json in padding,json就是javascript的字符串表现形式，服务器端可以对json进行收发解析。上面的文章给出了很详尽的解释，我就我学习中遇到的困难进行说明。</p>
<p>由于无法无法从不同源头的网站上直接获取JSON，但是我们平常的<code>&lt;script&gt;</code>标签是能够获取到别的网站的js文件，想想我们常常使用google的jquery吧，就像图片一样，可以随意使用。那么我们是不是可以将这个脚本的地址指向一个动态生成JSON的脚本呢？从而让它能够将生成的东西传到前端。显然这是可以的，和引入js相比只是动态与不动态的区别而已。但是传回来的东西应该是js代码，JSON不能直接使用，于是就用一个回调函数进行包裹。当它传回前端的时候就可以直接执行了。</p>
<p>维基百科的解释很容易懂，尤其是这个padding的意思：</p>
<p>这个时候，把 <code>&lt;script&gt;</code> 元素的 src 属性设成一个回传 JSON 的 URL 是可以想像的，这也代表从 HTML 页面透过 script 元素抓取 JSON 是可能的。然而，一份 JSON 文件并不是一个 JavaScript 程式。为了让浏览器可以在<code>&lt;script&gt;</code>元素执行，从 src 里 URL 回传的必须是可执行的 JavaScript。在 JSONP 的使用模式里，该 URL 回传的是由函数呼叫包起来的动态生成 JSON，这就是JSONP 的“填充（padding）”或是“前辍（prefix）”的由来。</p>
<h2 id="padding的形象体验"><a href="#padding的形象体验" class="headerlink" title="padding的形象体验"></a>padding的形象体验</h2><p>我在实际的编程中也用到了JSONP，本来可以直接使用<code>$callback.&#39;(&#39;.json_encode($data).&#39;)&#39;;</code>的方式直接返回的，但是这样每次都要写括号，很难看。于是我就将它写成了一个函数，并且支持多个参数：</p>
<pre><code>// PHP代码

// 带回调的响应
function callbackResponse($callback, $status=200, $data=&quot;&quot;, $extra=array())
{
    // 这里就是padding了,中间的JSON被夹起来了！形象吧
    echo $callback.&apos;(&apos;.ajaxResponse($status, $data, $extra).&apos;)&apos;;
    // include callback return of server end json data
    exit(0);
}

// 还是应该对返回内容进行merge后encode
function ajaxResponse($status=200, $data=&quot;&quot;, $extra=array()) {
    $ret = array(&quot;status&quot;=&gt;$status, &quot;data&quot;=&gt;$data);
    $ret = array_merge($ret, $extra);
    return json_encode($ret);
}

// ————————调用的例子————————
$callback = $_GET[&apos;callback&apos;];
callbackResponse($callback, 200, &quot;我爱编程&quot;);
</code></pre><p>在客户端可以是这样请求并处理的：</p>
<pre><code>// js代码
// callback作为一个参数传到服务端
$.getJSON(php_path+&apos;php/index.php?callback=?&apos;, function(ret_data) {
    if (ret_data.status == 200) 
    {
        console.log(ret_data[&apos;data&apos;]); // 我爱编程
        return;
    }
});
</code></pre><h2 id="jQuery的做法"><a href="#jQuery的做法" class="headerlink" title="jQuery的做法"></a>jQuery的做法</h2><p>上面看到jQuery中的$.getJSON方法支持在链接中直接放入callback函数，并且callback=?,其实它是把$.getJSON的第二个参数（一个匿名函数）作为一个callback函数，我们查看服务器返回的数据常常能够看到 <code>jQuery152042227689944248825_1317400799214({&quot;status&quot;: 200,&quot;data&quot;:&quot;我爱编程&quot;})</code>形式的包。本来是一个名字的，例如一个叫parseData的函数，callback=parseData,当JSONP返回之后，将直接执行<code>parseData({&quot;status&quot;: 200,&quot;data&quot;:&quot;我爱编程&quot;})</code>,也就是回调了。而jQuery直接帮我们处理了匿名函数的问题，相当于产生了一个名字随机的对象，让它等于这个匿名的回调函数。具体的还得看jQuery的源代码（笔者才看了一点，还没到能够解决这个问题的程度）。</p>
<p>如下jQuery源码:</p>
<pre><code>// 获取时间戳
var jsc = jQuery.now(), 
jsre = /(\=)\?(&amp;|$)|\?\?/i;

// 默认的jsonp设置
jQuery.ajaxSetup({
  jsonp: &quot;callback&quot;,   // 默认使用callback
  jsonpCallback: function() {
    return jQuery.expando + &quot;_&quot; + ( jsc++ );    // 构造回调前缀
  }
});
// 下面的代码，额。。
jQuery.ajaxPrefilter( &quot;json jsonp&quot;, function( s, originalSettings, jqXHR ) {

  var inspectData = s.contentType === &quot;application/x-www-form-urlencoded&quot; &amp;&amp;
    ( typeof s.data === &quot;string&quot; );

  if ( s.dataTypes[ 0 ] === &quot;jsonp&quot; ||
    s.jsonp !== false &amp;&amp; ( jsre.test( s.url ) ||
        inspectData &amp;&amp; jsre.test( s.data ) ) ) {

    // 设置jsonCallback,当回调时，就能直接调用了
    var responseContainer,
      jsonpCallback = s.jsonpCallback =
        jQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback,
      previous = window[ jsonpCallback ],
      url = s.url,
      data = s.data,
      replace = &quot;$1&quot; + jsonpCallback + &quot;$2&quot;;

    if ( s.jsonp !== false ) {
      url = url.replace( jsre, replace );
      if ( s.url === url ) {
        if ( inspectData ) {
          data = data.replace( jsre, replace );
        }
        if ( s.data === data ) {
          url += (/\?/.test( url ) ? &quot;&amp;&quot; : &quot;?&quot;) + s.jsonp + &quot;=&quot; + jsonpCallback;
        }
      }
    }

    s.url = url;
    s.data = data;

    window[ jsonpCallback ] = function( response ) {
      responseContainer = [ response ];
    };

    jqXHR.always(function() {

      window[ jsonpCallback ] = previous;

      if ( responseContainer &amp;&amp; jQuery.isFunction( previous ) ) {
        window[ jsonpCallback ]( responseContainer[ 0 ] );
      }
    });

    s.converters[&quot;script json&quot;] = function() {
      if ( !responseContainer ) {
        jQuery.error( jsonpCallback + &quot; was not called&quot; );
      }
      return responseContainer[ 0 ];
    };

    s.dataTypes[ 0 ] = &quot;json&quot;;


    return &quot;script&quot;;
  }
});
</code></pre><p>// TODO: 读通源代码</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://zh.wikipedia.org/wiki/JSONP" target="_blank" rel="noopener">wikipadia</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/bitcoin-cash-logo.svg"
               alt="bibodeng" />
          <p class="site-author-name" itemprop="name">bibodeng</p>
          <p class="site-description motion-element" itemprop="description">区块链爱好者，互联网从业者</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">180</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/bibodeng" target="_blank" title="Github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/bibodeng" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/bibodeng" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://ifwallet.com" title="IFWallet" target="_blank">IFWallet</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://ifpass.cash" title="IFPassword" target="_blank">IFPassword</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bibodeng</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("RrMSWOa8nuCnCCWn8TyPa7Od-gzGzoHsz", "8xnzit83sqv6vUEuXlsEWe0s");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
