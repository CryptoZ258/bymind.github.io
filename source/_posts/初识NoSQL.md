---
title: 初识NoSQL
date: 2013-10-27 17:35:23
---
#初识NoSQL
by bibodeng 2013-10-27

## Not only SQL

之前就接触过NoSQL，但是从来没有再项目实践中使用过。故而，很有必要从入门之初就动手操练一下，就算不太熟练，也能知道其中精华一二。我告诫自己，要紧凑明确，对任何东西都有意识地围绕最核心的东西去发问，凡事问个为什么，不要浪费太多时间在不重要的踌躇中。我之前看过一点NoSQL，毕竟没有什么实战经验，所以忘得也快，现在复习一下。


现代互联应用网对于数据库的要求：

1. 低延迟的读写速度：应用快速地反应能极大地提升用户的满意度; 
2. 支撑海量的数据和流量：对于搜索这样大型应用而言，需要利用PB级别的数据和能应对百万级的流量; 
3. 大规模集群的管理：系统管理员希望分布式应用能更简单的部署和管理; 
4. 庞大运营成本的考量：IT经理们希望在硬件成本、软件成本和人力成本能够有大幅度地降低; 

关系型数据库的优势在于：

1. 事务支持 （如MySQL的 InnoDB引擎）
2. 进行复杂查询 （join，几个表联合起来查询）
3. 技术成熟 （oracle， MySQL， SQLServer）

NoSQL是一种新型的数据库，和关系型数据库有所不同，在以下方面具有优势:

1. 适合分布式，简单的扩展：典型例子是Cassandra，由于其架构是类似于经典的P2P，所以能通过轻松地添加新的节点来扩展这个集群; 
2. 快速的读写：主要例子有Redis，由于其逻辑简单，而且纯内存操作，使得其性能非常出色，单节点每秒可以处理超过10万次读写操作; 
3. 低廉的成本：这是大多数分布式数据库共有的特点，因为主要都是开源软件，没有昂贵的License成本; 

以上几点来自互联网，到目前我还没有直观的感受。NoSQL有很多种类型，常见的有Memcached, Redis, MongoDB(和JS有很大渊源)等。

![nosql类型](http://www.bibodeng.com/content/plugins/kl_album/upload/201310/c7f3d4b3c551949a9f63c2dcc656294e2013102707103327065.png)

键值存储类型的NoSQL数据库，主要是在内存中记录一些经常使用的数据，例如数据库的主键，这就就能够快速存取，而在内存中虽然快，但是存取不够可靠，有可能会丢失，造成数据的不一致性。故而，有一种策略就是当键值修改频率大过某个值的时候，就将缓存的数据给写到磁盘中去。Memcached也可以同MySQL搭配使用（互补），PHP有提供其驱动及接口，我们熟悉的SAE就是采用主从数据库+Memcached的架构。

面向文档的数据库，是将数据以文档的形式存储，其实是类似JSON的格式，也是键值对。

### Memcached

使用散列表的方式存储键值对，全部存储在内存中，故而相当高速，可以很好地改善延迟。

**一致性散列技术**：

如果有多台服务器，原理上是使用总数据量除以服务器台数取余来决定散列到哪个服务器，但是当有服务器加入进来时，这个计算到的余数会发生变化。如mod 4 变成 mod5,会有相当数据要重新散列。

而一致性散列将一个范围内的数据，散列到一个圆周上的各个服务器中。并且对于均衡负载，扩展集群，数据迁移等具有良好的支持。并且当有服务器发生故障时，影响的是一部分的数据，有服务器加入进来时，不会因为重新散列找不到数据了，而是只影响少量的数据（需从旧节点迁移到新节点），也即将原来范围内的一部分数据迁移就可以了。如下图所示：

![散列一致性](http://www.bibodeng.com/content/plugins/kl_album/upload/201310/0053dd31c19d94a02d797b2f513fb733201310270816487506.png)

那么具体它是怎么计算，让部分服务器4的数据散列到服务器5呢？

根据key算出hash值，选择第一个大于该hash值的虚节点server，系统维护了一个server list，每个server具有多个虚节点。也即它的数据不是由服务器数量决定放在哪里的，而是对一个更大的数进行散列，由服务器位置来决定的。

**缺陷**：

一定要使用明确的查询条件，就像hash_table数据结构一样，所以不能像关系型一样用`LIKE`。


**启动**：

	// 启动   后台运行  端口   用户名    链接数   内存限制
	memcached -d -p 12345 -u uname -c 1024 -m 512 

**使用**：

	// 设置键值对 键， 是否压缩， 过期时间戳， 大小
	set <key> <flag> <expires> <byte>
	<value> // 存储的值

	// 获取值
	get <key> // 返回key对于的value

	// 清空
	flush_all 
	// flush后数据所占的内存并不会被释放，但会被标记为过期，是不能再被取得了

**编程语言中的使用**：

请参考[PHP memcached手册](http://www.php.net/manual/zh/book.memcached.php)
	
	$options = array( 
		'servers' => array('192.168.1.1:11211'), //memcached 服务的地址、端口，可用多个数组元素表示多个 memcached 服务 
		'debug' => true, 						//是否打开 debug 
		'compress_threshold' => 10240, 			//超过多少字节的数据时进行压缩 
		'persistant' => false 					//是否使用持久连接 
	); 
	// 创建 memcached 对象实例 
	$mc = new memcached($options); 
	// 设置此脚本使用的唯一标识符 
	$key = 'mykey'; 
	// 往 memcached 中写入对象 
	$mc->add($key, 'some random strings'); 
	// 取出该值
	$val = $mc->get($key); 
	// 替换已写入的对象数据值 
	$mc->replace($key, array('some'=>'haha', 'array'=>'xxx')); 
	// 删除一个值
	$mc->delete($key); 

可见，在编程语言中，这样使用memcache数据库已经非常方便了，直接对键值进行存取删除。所以我们就可以在程序中将一些常用的值缓存起来，例如一个获取最新微博的查询，那么我们可以缓存这些微博，当有人刷的时候，就从缓存返回，将大大提升访问速度。

Redis和memcached有点类似，但是它可以进行永久性的键值存储，所以相对又更靠后一点。

### MongoDB

MongoDB是无需定义表结构的一种文档型数据库，和关系型一定要确定表的结构，存储各个字段有很大不同。MongoDB是以BSON（binary JSON）的方式来存储数据的，也是以键值的方式对应起来。多个文档可以组成一个集合（对应表），多个集合构成了数据库。	

但是MongoDB不支持JOIN查询以及事务处理。且不是实时写入磁盘，而是有一定的延时。

其MongoDB shell是数据库的管理工具，其脚本语言和JS类似。一些常用的操作可以参考[例子](http://www.cnblogs.com/archie2010/archive/2012/10/07/2712937.html)。以前我一直在担心，这样的键值对存在文档里面，其存取速度会不会很慢呢？它是取得JSON，转化为内存中的对象进行操作的么？

我看到了这样一段话：

>在使用场合下，千万级别的文档对象，近10G的数据，对有索引的ID的查询不会比mysql慢，而对非索引字段的查询，则是全面胜出。 mysql实际无法胜任大数据量下任意字段的查询，而mongodb的查询性能实在让我惊讶。写入性能同样很令人满意。

具体的测试例子，已经有哥们用号称亿级数据进行了[测试](http://www.cnblogs.com/lovecindywang/archive/2011/03/02/1969324.html)。

后续将会继续深入探索NoSQL数据库。
___
end